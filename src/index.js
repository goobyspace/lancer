function e(e,t,a,o){var n,r=arguments.length,s=r<3?t:null===o?o=Object.getOwnPropertyDescriptor(t,a):o;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)s=Reflect.decorate(e,t,a,o);else for(var i=e.length-1;i>=0;i--)(n=e[i])&&(s=(r<3?n(s):r>3?n(t,a,s):n(t,a))||s);return r>3&&s&&Object.defineProperty(t,a,s),s}"function"==typeof SuppressedError&&SuppressedError;
/**
 * @license
 * Copyright 2019 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const t=globalThis,a=t.ShadowRoot&&(void 0===t.ShadyCSS||t.ShadyCSS.nativeShadow)&&"adoptedStyleSheets"in Document.prototype&&"replace"in CSSStyleSheet.prototype,o=Symbol(),n=new WeakMap;let r=class{constructor(e,t,a){if(this._$cssResult$=!0,a!==o)throw Error("CSSResult is not constructable. Use `unsafeCSS` or `css` instead.");this.cssText=e,this.t=t}get styleSheet(){let e=this.o;const t=this.t;if(a&&void 0===e){const a=void 0!==t&&1===t.length;a&&(e=n.get(t)),void 0===e&&((this.o=e=new CSSStyleSheet).replaceSync(this.cssText),a&&n.set(t,e))}return e}toString(){return this.cssText}};const s=(e,...t)=>{const a=1===e.length?e[0]:t.reduce(((t,a,o)=>t+(e=>{if(!0===e._$cssResult$)return e.cssText;if("number"==typeof e)return e;throw Error("Value passed to 'css' function must be a 'css' function result: "+e+". Use 'unsafeCSS' to pass non-literal values, but take care to ensure page security.")})(a)+e[o+1]),e[0]);return new r(a,e,o)},i=a?e=>e:e=>e instanceof CSSStyleSheet?(e=>{let t="";for(const a of e.cssRules)t+=a.cssText;return(e=>new r("string"==typeof e?e:e+"",void 0,o))(t)})(e):e
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */,{is:c,defineProperty:h,getOwnPropertyDescriptor:l,getOwnPropertyNames:d,getOwnPropertySymbols:m,getPrototypeOf:u}=Object,$=globalThis,g=$.trustedTypes,p=g?g.emptyScript:"",y=$.reactiveElementPolyfillSupport,f=(e,t)=>e,b={toAttribute(e,t){switch(t){case Boolean:e=e?p:null;break;case Object:case Array:e=null==e?e:JSON.stringify(e)}return e},fromAttribute(e,t){let a=e;switch(t){case Boolean:a=null!==e;break;case Number:a=null===e?null:Number(e);break;case Object:case Array:try{a=JSON.parse(e)}catch(e){a=null}}return a}},w=(e,t)=>!c(e,t),k={attribute:!0,type:String,converter:b,reflect:!1,hasChanged:w};Symbol.metadata??=Symbol("metadata"),$.litPropertyMetadata??=new WeakMap;class v extends HTMLElement{static addInitializer(e){this._$Ei(),(this.l??=[]).push(e)}static get observedAttributes(){return this.finalize(),this._$Eh&&[...this._$Eh.keys()]}static createProperty(e,t=k){if(t.state&&(t.attribute=!1),this._$Ei(),this.elementProperties.set(e,t),!t.noAccessor){const a=Symbol(),o=this.getPropertyDescriptor(e,a,t);void 0!==o&&h(this.prototype,e,o)}}static getPropertyDescriptor(e,t,a){const{get:o,set:n}=l(this.prototype,e)??{get(){return this[t]},set(e){this[t]=e}};return{get(){return o?.call(this)},set(t){const r=o?.call(this);n.call(this,t),this.requestUpdate(e,r,a)},configurable:!0,enumerable:!0}}static getPropertyOptions(e){return this.elementProperties.get(e)??k}static _$Ei(){if(this.hasOwnProperty(f("elementProperties")))return;const e=u(this);e.finalize(),void 0!==e.l&&(this.l=[...e.l]),this.elementProperties=new Map(e.elementProperties)}static finalize(){if(this.hasOwnProperty(f("finalized")))return;if(this.finalized=!0,this._$Ei(),this.hasOwnProperty(f("properties"))){const e=this.properties,t=[...d(e),...m(e)];for(const a of t)this.createProperty(a,e[a])}const e=this[Symbol.metadata];if(null!==e){const t=litPropertyMetadata.get(e);if(void 0!==t)for(const[e,a]of t)this.elementProperties.set(e,a)}this._$Eh=new Map;for(const[e,t]of this.elementProperties){const a=this._$Eu(e,t);void 0!==a&&this._$Eh.set(a,e)}this.elementStyles=this.finalizeStyles(this.styles)}static finalizeStyles(e){const t=[];if(Array.isArray(e)){const a=new Set(e.flat(1/0).reverse());for(const e of a)t.unshift(i(e))}else void 0!==e&&t.push(i(e));return t}static _$Eu(e,t){const a=t.attribute;return!1===a?void 0:"string"==typeof a?a:"string"==typeof e?e.toLowerCase():void 0}constructor(){super(),this._$Ep=void 0,this.isUpdatePending=!1,this.hasUpdated=!1,this._$Em=null,this._$Ev()}_$Ev(){this._$ES=new Promise((e=>this.enableUpdating=e)),this._$AL=new Map,this._$E_(),this.requestUpdate(),this.constructor.l?.forEach((e=>e(this)))}addController(e){(this._$EO??=new Set).add(e),void 0!==this.renderRoot&&this.isConnected&&e.hostConnected?.()}removeController(e){this._$EO?.delete(e)}_$E_(){const e=new Map,t=this.constructor.elementProperties;for(const a of t.keys())this.hasOwnProperty(a)&&(e.set(a,this[a]),delete this[a]);e.size>0&&(this._$Ep=e)}createRenderRoot(){const e=this.shadowRoot??this.attachShadow(this.constructor.shadowRootOptions);return((e,o)=>{if(a)e.adoptedStyleSheets=o.map((e=>e instanceof CSSStyleSheet?e:e.styleSheet));else for(const a of o){const o=document.createElement("style"),n=t.litNonce;void 0!==n&&o.setAttribute("nonce",n),o.textContent=a.cssText,e.appendChild(o)}})(e,this.constructor.elementStyles),e}connectedCallback(){this.renderRoot??=this.createRenderRoot(),this.enableUpdating(!0),this._$EO?.forEach((e=>e.hostConnected?.()))}enableUpdating(e){}disconnectedCallback(){this._$EO?.forEach((e=>e.hostDisconnected?.()))}attributeChangedCallback(e,t,a){this._$AK(e,a)}_$EC(e,t){const a=this.constructor.elementProperties.get(e),o=this.constructor._$Eu(e,a);if(void 0!==o&&!0===a.reflect){const n=(void 0!==a.converter?.toAttribute?a.converter:b).toAttribute(t,a.type);this._$Em=e,null==n?this.removeAttribute(o):this.setAttribute(o,n),this._$Em=null}}_$AK(e,t){const a=this.constructor,o=a._$Eh.get(e);if(void 0!==o&&this._$Em!==o){const e=a.getPropertyOptions(o),n="function"==typeof e.converter?{fromAttribute:e.converter}:void 0!==e.converter?.fromAttribute?e.converter:b;this._$Em=o,this[o]=n.fromAttribute(t,e.type),this._$Em=null}}requestUpdate(e,t,a){if(void 0!==e){if(a??=this.constructor.getPropertyOptions(e),!(a.hasChanged??w)(this[e],t))return;this.P(e,t,a)}!1===this.isUpdatePending&&(this._$ES=this._$ET())}P(e,t,a){this._$AL.has(e)||this._$AL.set(e,t),!0===a.reflect&&this._$Em!==e&&(this._$Ej??=new Set).add(e)}async _$ET(){this.isUpdatePending=!0;try{await this._$ES}catch(e){Promise.reject(e)}const e=this.scheduleUpdate();return null!=e&&await e,!this.isUpdatePending}scheduleUpdate(){return this.performUpdate()}performUpdate(){if(!this.isUpdatePending)return;if(!this.hasUpdated){if(this.renderRoot??=this.createRenderRoot(),this._$Ep){for(const[e,t]of this._$Ep)this[e]=t;this._$Ep=void 0}const e=this.constructor.elementProperties;if(e.size>0)for(const[t,a]of e)!0!==a.wrapped||this._$AL.has(t)||void 0===this[t]||this.P(t,this[t],a)}let e=!1;const t=this._$AL;try{e=this.shouldUpdate(t),e?(this.willUpdate(t),this._$EO?.forEach((e=>e.hostUpdate?.())),this.update(t)):this._$EU()}catch(t){throw e=!1,this._$EU(),t}e&&this._$AE(t)}willUpdate(e){}_$AE(e){this._$EO?.forEach((e=>e.hostUpdated?.())),this.hasUpdated||(this.hasUpdated=!0,this.firstUpdated(e)),this.updated(e)}_$EU(){this._$AL=new Map,this.isUpdatePending=!1}get updateComplete(){return this.getUpdateComplete()}getUpdateComplete(){return this._$ES}shouldUpdate(e){return!0}update(e){this._$Ej&&=this._$Ej.forEach((e=>this._$EC(e,this[e]))),this._$EU()}updated(e){}firstUpdated(e){}}v.elementStyles=[],v.shadowRootOptions={mode:"open"},v[f("elementProperties")]=new Map,v[f("finalized")]=new Map,y?.({ReactiveElement:v}),($.reactiveElementVersions??=[]).push("2.0.4");
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const _=globalThis,x=_.trustedTypes,C=x?x.createPolicy("lit-html",{createHTML:e=>e}):void 0,A="$lit$",T=`lit$${Math.random().toFixed(9).slice(2)}$`,S="?"+T,E=`<${S}>`,I=document,j=()=>I.createComment(""),P=e=>null===e||"object"!=typeof e&&"function"!=typeof e,M=Array.isArray,q="[ \t\n\f\r]",O=/<(?:(!--|\/[^a-zA-Z])|(\/?[a-zA-Z][^>\s]*)|(\/?$))/g,z=/-->/g,R=/>/g,H=RegExp(`>|${q}(?:([^\\s"'>=/]+)(${q}*=${q}*(?:[^ \t\n\f\r"'\`<>=]|("|')|))|$)`,"g"),W=/'/g,N=/"/g,U=/^(?:script|style|textarea|title)$/i,L=(e=>(t,...a)=>({_$litType$:e,strings:t,values:a}))(1),Y=Symbol.for("lit-noChange"),G=Symbol.for("lit-nothing"),B=new WeakMap,F=I.createTreeWalker(I,129);function D(e,t){if(!M(e)||!e.hasOwnProperty("raw"))throw Error("invalid template strings array");return void 0!==C?C.createHTML(t):t}const X=(e,t)=>{const a=e.length-1,o=[];let n,r=2===t?"<svg>":3===t?"<math>":"",s=O;for(let t=0;t<a;t++){const a=e[t];let i,c,h=-1,l=0;for(;l<a.length&&(s.lastIndex=l,c=s.exec(a),null!==c);)l=s.lastIndex,s===O?"!--"===c[1]?s=z:void 0!==c[1]?s=R:void 0!==c[2]?(U.test(c[2])&&(n=RegExp("</"+c[2],"g")),s=H):void 0!==c[3]&&(s=H):s===H?">"===c[0]?(s=n??O,h=-1):void 0===c[1]?h=-2:(h=s.lastIndex-c[2].length,i=c[1],s=void 0===c[3]?H:'"'===c[3]?N:W):s===N||s===W?s=H:s===z||s===R?s=O:(s=H,n=void 0);const d=s===H&&e[t+1].startsWith("/>")?" ":"";r+=s===O?a+E:h>=0?(o.push(i),a.slice(0,h)+A+a.slice(h)+T+d):a+T+(-2===h?t:d)}return[D(e,r+(e[a]||"<?>")+(2===t?"</svg>":3===t?"</math>":"")),o]};class K{constructor({strings:e,_$litType$:t},a){let o;this.parts=[];let n=0,r=0;const s=e.length-1,i=this.parts,[c,h]=X(e,t);if(this.el=K.createElement(c,a),F.currentNode=this.el.content,2===t||3===t){const e=this.el.content.firstChild;e.replaceWith(...e.childNodes)}for(;null!==(o=F.nextNode())&&i.length<s;){if(1===o.nodeType){if(o.hasAttributes())for(const e of o.getAttributeNames())if(e.endsWith(A)){const t=h[r++],a=o.getAttribute(e).split(T),s=/([.?@])?(.*)/.exec(t);i.push({type:1,index:n,name:s[2],strings:a,ctor:"."===s[1]?ee:"?"===s[1]?te:"@"===s[1]?ae:Z}),o.removeAttribute(e)}else e.startsWith(T)&&(i.push({type:6,index:n}),o.removeAttribute(e));if(U.test(o.tagName)){const e=o.textContent.split(T),t=e.length-1;if(t>0){o.textContent=x?x.emptyScript:"";for(let a=0;a<t;a++)o.append(e[a],j()),F.nextNode(),i.push({type:2,index:++n});o.append(e[t],j())}}}else if(8===o.nodeType)if(o.data===S)i.push({type:2,index:n});else{let e=-1;for(;-1!==(e=o.data.indexOf(T,e+1));)i.push({type:7,index:n}),e+=T.length-1}n++}}static createElement(e,t){const a=I.createElement("template");return a.innerHTML=e,a}}function V(e,t,a=e,o){if(t===Y)return t;let n=void 0!==o?a._$Co?.[o]:a._$Cl;const r=P(t)?void 0:t._$litDirective$;return n?.constructor!==r&&(n?._$AO?.(!1),void 0===r?n=void 0:(n=new r(e),n._$AT(e,a,o)),void 0!==o?(a._$Co??=[])[o]=n:a._$Cl=n),void 0!==n&&(t=V(e,n._$AS(e,t.values),n,o)),t}class Q{constructor(e,t){this._$AV=[],this._$AN=void 0,this._$AD=e,this._$AM=t}get parentNode(){return this._$AM.parentNode}get _$AU(){return this._$AM._$AU}u(e){const{el:{content:t},parts:a}=this._$AD,o=(e?.creationScope??I).importNode(t,!0);F.currentNode=o;let n=F.nextNode(),r=0,s=0,i=a[0];for(;void 0!==i;){if(r===i.index){let t;2===i.type?t=new J(n,n.nextSibling,this,e):1===i.type?t=new i.ctor(n,i.name,i.strings,this,e):6===i.type&&(t=new oe(n,this,e)),this._$AV.push(t),i=a[++s]}r!==i?.index&&(n=F.nextNode(),r++)}return F.currentNode=I,o}p(e){let t=0;for(const a of this._$AV)void 0!==a&&(void 0!==a.strings?(a._$AI(e,a,t),t+=a.strings.length-2):a._$AI(e[t])),t++}}class J{get _$AU(){return this._$AM?._$AU??this._$Cv}constructor(e,t,a,o){this.type=2,this._$AH=G,this._$AN=void 0,this._$AA=e,this._$AB=t,this._$AM=a,this.options=o,this._$Cv=o?.isConnected??!0}get parentNode(){let e=this._$AA.parentNode;const t=this._$AM;return void 0!==t&&11===e?.nodeType&&(e=t.parentNode),e}get startNode(){return this._$AA}get endNode(){return this._$AB}_$AI(e,t=this){e=V(this,e,t),P(e)?e===G||null==e||""===e?(this._$AH!==G&&this._$AR(),this._$AH=G):e!==this._$AH&&e!==Y&&this._(e):void 0!==e._$litType$?this.$(e):void 0!==e.nodeType?this.T(e):(e=>M(e)||"function"==typeof e?.[Symbol.iterator])(e)?this.k(e):this._(e)}O(e){return this._$AA.parentNode.insertBefore(e,this._$AB)}T(e){this._$AH!==e&&(this._$AR(),this._$AH=this.O(e))}_(e){this._$AH!==G&&P(this._$AH)?this._$AA.nextSibling.data=e:this.T(I.createTextNode(e)),this._$AH=e}$(e){const{values:t,_$litType$:a}=e,o="number"==typeof a?this._$AC(e):(void 0===a.el&&(a.el=K.createElement(D(a.h,a.h[0]),this.options)),a);if(this._$AH?._$AD===o)this._$AH.p(t);else{const e=new Q(o,this),a=e.u(this.options);e.p(t),this.T(a),this._$AH=e}}_$AC(e){let t=B.get(e.strings);return void 0===t&&B.set(e.strings,t=new K(e)),t}k(e){M(this._$AH)||(this._$AH=[],this._$AR());const t=this._$AH;let a,o=0;for(const n of e)o===t.length?t.push(a=new J(this.O(j()),this.O(j()),this,this.options)):a=t[o],a._$AI(n),o++;o<t.length&&(this._$AR(a&&a._$AB.nextSibling,o),t.length=o)}_$AR(e=this._$AA.nextSibling,t){for(this._$AP?.(!1,!0,t);e&&e!==this._$AB;){const t=e.nextSibling;e.remove(),e=t}}setConnected(e){void 0===this._$AM&&(this._$Cv=e,this._$AP?.(e))}}class Z{get tagName(){return this.element.tagName}get _$AU(){return this._$AM._$AU}constructor(e,t,a,o,n){this.type=1,this._$AH=G,this._$AN=void 0,this.element=e,this.name=t,this._$AM=o,this.options=n,a.length>2||""!==a[0]||""!==a[1]?(this._$AH=Array(a.length-1).fill(new String),this.strings=a):this._$AH=G}_$AI(e,t=this,a,o){const n=this.strings;let r=!1;if(void 0===n)e=V(this,e,t,0),r=!P(e)||e!==this._$AH&&e!==Y,r&&(this._$AH=e);else{const o=e;let s,i;for(e=n[0],s=0;s<n.length-1;s++)i=V(this,o[a+s],t,s),i===Y&&(i=this._$AH[s]),r||=!P(i)||i!==this._$AH[s],i===G?e=G:e!==G&&(e+=(i??"")+n[s+1]),this._$AH[s]=i}r&&!o&&this.j(e)}j(e){e===G?this.element.removeAttribute(this.name):this.element.setAttribute(this.name,e??"")}}class ee extends Z{constructor(){super(...arguments),this.type=3}j(e){this.element[this.name]=e===G?void 0:e}}class te extends Z{constructor(){super(...arguments),this.type=4}j(e){this.element.toggleAttribute(this.name,!!e&&e!==G)}}class ae extends Z{constructor(e,t,a,o,n){super(e,t,a,o,n),this.type=5}_$AI(e,t=this){if((e=V(this,e,t,0)??G)===Y)return;const a=this._$AH,o=e===G&&a!==G||e.capture!==a.capture||e.once!==a.once||e.passive!==a.passive,n=e!==G&&(a===G||o);o&&this.element.removeEventListener(this.name,this,a),n&&this.element.addEventListener(this.name,this,e),this._$AH=e}handleEvent(e){"function"==typeof this._$AH?this._$AH.call(this.options?.host??this.element,e):this._$AH.handleEvent(e)}}class oe{constructor(e,t,a){this.element=e,this.type=6,this._$AN=void 0,this._$AM=t,this.options=a}get _$AU(){return this._$AM._$AU}_$AI(e){V(this,e)}}const ne=_.litHtmlPolyfillSupport;ne?.(K,J),(_.litHtmlVersions??=[]).push("3.2.1");
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
let re=class extends v{constructor(){super(...arguments),this.renderOptions={host:this},this._$Do=void 0}createRenderRoot(){const e=super.createRenderRoot();return this.renderOptions.renderBefore??=e.firstChild,e}update(e){const t=this.render();this.hasUpdated||(this.renderOptions.isConnected=this.isConnected),super.update(e),this._$Do=((e,t,a)=>{const o=a?.renderBefore??t;let n=o._$litPart$;if(void 0===n){const e=a?.renderBefore??null;o._$litPart$=n=new J(t.insertBefore(j(),e),e,void 0,a??{})}return n._$AI(e),n})(t,this.renderRoot,this.renderOptions)}connectedCallback(){super.connectedCallback(),this._$Do?.setConnected(!0)}disconnectedCallback(){super.disconnectedCallback(),this._$Do?.setConnected(!1)}render(){return Y}};re._$litElement$=!0,re.finalized=!0,globalThis.litElementHydrateSupport?.({LitElement:re});const se=globalThis.litElementPolyfillSupport;se?.({LitElement:re}),(globalThis.litElementVersions??=[]).push("4.1.1");
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const ie={attribute:!0,type:String,converter:b,reflect:!1,hasChanged:w},ce=(e=ie,t,a)=>{const{kind:o,metadata:n}=a;let r=globalThis.litPropertyMetadata.get(n);if(void 0===r&&globalThis.litPropertyMetadata.set(n,r=new Map),r.set(a.name,e),"accessor"===o){const{name:o}=a;return{set(a){const n=t.get.call(this);t.set.call(this,a),this.requestUpdate(o,n,e)},init(t){return void 0!==t&&this.P(o,void 0,e),t}}}if("setter"===o){const{name:o}=a;return function(a){const n=this[o];t.call(this,a),this.requestUpdate(o,n,e)}}throw Error("Unsupported decorator location: "+o)};function he(e){return(t,a)=>"object"==typeof a?ce(e,t,a):((e,t,a)=>{const o=t.hasOwnProperty(a);return t.constructor.createProperty(a,o?{...e,wrapped:!0}:e),o?Object.getOwnPropertyDescriptor(t,a):void 0})(e,t,a)}const le=s`
  :host {
    font-family: 'Inter', 'Roboto', sans-serif;
  }

  .lancer-keyword {
    font-weight: 700;
    color: #231f20;
    cursor: pointer;
    font-family: 'Inter', 'Roboto', sans-serif;
    font-size: 1rem;
    transition: 0.3s;
    text-transform: uppercase;
    display: inline-block;
    position: relative;
    margin: 0;
    padding: 0;

    &::after {
      content: '';
      position: absolute;
      width: 100%;
      transform: scaleX(0);
      height: 2px;
      bottom: 0;
      left: 0;
      transform-origin: bottom right;
      transition: transform 0.25s ease-out;
    }

    &:hover::after {
      transform: scaleX(1);
      transform-origin: bottom left;
    }

    &.lancer-keyword-ai {
      color: #ccac10;
    }

    &.lancer-keyword-ai::after {
      background: #ccac10;
    }

    &.lancer-keyword-attacks {
      color: #720003;
    }

    &.lancer-keyword-attacks::after {
      background: #720003;
    }

    &.lancer-keyword-bonuses {
      color: #0070c0;
    }

    &.lancer-keyword-bonuses::after {
      background: #0070c0;
    }

    &.lancer-keyword-combat {
      color: #c22026;
    }

    &.lancer-keyword-combat::after {
      background: #c22026;
    }

    &.lancer-keyword-conditions {
      color: #c75a00;
    }

    &.lancer-keyword-conditions::after {
      background: #c75a00;
    }

    &.lancer-keyword-fullaction {
      color: #68bd45;
    }

    &.lancer-keyword-fullaction::after {
      background: #68bd45;
    }

    &.lancer-keyword-gear {
      color: #4b000e;
    }

    &.lancer-keyword-gear::after {
      background: #4b000e;
    }

    &.lancer-keyword-harm {
      color: #720003;
    }

    &.lancer-keyword-harm::after {
      background: #720003;
    }

    &.lancer-keyword-mech {
      color: #e1484c;
    }

    &.lancer-keyword-mech::after {
      background: #e1484c;
    }

    &.lancer-keyword-movement {
      color: #2b30bd;
    }

    &.lancer-keyword-movement::after {
      background: #2b30bd;
    }

    &.lancer-keyword-otheraction {
      color: #68bd45;
    }

    &.lancer-keyword-otheraction::after {
      background: #68bd45;
    }

    &.lancer-keyword-pilot {
      color: #48666e;
    }

    &.lancer-keyword-pilot::after {
      background: #48666e;
    }

    &.lancer-keyword-pilotgear {
      color: #471016;
    }

    &.lancer-keyword-pilotgear::after {
      background: #471016;
    }

    &.lancer-keyword-quickaction {
      color: #68bd45;
    }

    &.lancer-keyword-quickaction::after {
      background: #68bd45;
    }

    &.lancer-keyword-reaction {
      color: #0b7675;
    }

    &.lancer-keyword-reaction::after {
      background: #0b7675;
    }

    &.lancer-keyword-status {
      color: #c75a00;
    }

    &.lancer-keyword-status::after {
      background: #c75a00;
    }

    &.lancer-keyword-techaction {
      color: #7e2477;
    }

    &.lancer-keyword-techaction::after {
      background: #7e2477;
    }

    &.lancer-keyword-weapon {
      color: #000000;
    }

    &.lancer-keyword-weapon::after {
      background: #000000;
    }
  }
`,de=s`
  .lancer-card-clickthrough {
    position: fixed;
    top: 0;
    left: 0;
    height: 100vh;
    width: 100vw;
  }

  .lancer-card {
    display: block;
    padding: 0;
    margin: 0;
    position: absolute;
    width: 40rem;
    font-family: 'Inter', 'Roboto', sans-serif;
    white-space: normal;

    .lancer-card-header {
      font-weight: 700;
      display: flex;
      justify-content: space-between;
      padding: 0;
      margin: 0;
      color: white;
      border-right: 2rem solid transparent;
      height: 0;
      width: calc(100%-2rem);

      .lancer-card-header-name {
        text-transform: uppercase;
      }

      p {
        margin: 0;
        padding: 0.25rem;
        height: 1rem;
      }
      .lancer-card-header-category {
        text-transform: capitalize;
      }
    }
    .lancer-card-body {
      margin: 0;
      display: block;
      overflow: hidden;

      .lancer-card-body-text {
        display: inline;
        padding: 0.25rem;
        box-decoration-break: clone;
        color: #231f20;
        margin: 0;
        white-space: pre-wrap;
      }

      .lancer-card-page {
        font-weight: 700;
        float: right;
        margin-top: 0.5rem;
        padding: 0;
        background-color: #d21c21;
        border-radius: 0.5rem 0 0 0;
        display: flex;
        justify-content: end;
        align-items: end;

        .lancer-card-page-number {
          margin: 0;
          padding: 0.25rem;
          color: white;
        }
      }
    }

    .lancer-card-body-clear {
      clear: both;
    }

    &.lancer-card-ai {
      .lancer-card-header {
        border-bottom: 1.5rem solid #ccac10;
      }
      .lancer-card-body {
        background-color: #f9f4e9;
      }
    }

    &.lancer-card-attacks {
      .lancer-card-header {
        border-bottom: 1.5rem solid #900002;
      }
      .lancer-card-body {
        background-color: #f9e9e9;
      }
    }

    &.lancer-card-bonuses {
      .lancer-card-header {
        border-bottom: 1.5rem solid #3a82c4;
      }
      .lancer-card-body {
        background-color: #d8e6f3;
      }
    }

    &.lancer-card-combat {
      .lancer-card-header {
        border-bottom: 1.5rem solid #c22026;
      }
      .lancer-card-body {
        background-color: #f9e9e9;
      }
    }

    &.lancer-card-conditions {
      .lancer-card-header {
        border-bottom: 1.5rem solid #c75a00;
      }
      .lancer-card-body {
        background-color: #f9efe6;
      }
    }

    &.lancer-card-fullaction {
      .lancer-card-header {
        border-bottom: 1.5rem solid #68bd45;
      }
      .lancer-card-body {
        background-color: #e1f2da;
      }
    }

    &.lancer-card-gear {
      .lancer-card-header {
        border-bottom: 1.5rem solid #4b000e;
      }
      .lancer-card-body {
        background-color: #ede7e8;
      }
    }

    &.lancer-card-harm {
      .lancer-card-header {
        border-bottom: 1.5rem solid #720003;
      }
      .lancer-card-body {
        background-color: #f9e9e9;
      }
    }

    &.lancer-card-mech {
      .lancer-card-header {
        border-bottom: 1.5rem solid #e1484c;
      }
      .lancer-card-body {
        background-color: #f9e9e9;
      }
    }

    &.lancer-card-movement {
      .lancer-card-header {
        border-bottom: 1.5rem solid #2b30bd;
      }
      .lancer-card-body {
        background-color: #e9e9f9;
      }
    }

    &.lancer-card-otheraction {
      .lancer-card-header {
        border-bottom: 1.5rem solid #68bd45;
      }
      .lancer-card-body {
        background-color: #e1f2da;
      }
    }

    &.lancer-card-pilot {
      .lancer-card-header {
        border-bottom: 1.5rem solid #48666e;
      }
      .lancer-card-body {
        background-color: #e7ecee;
      }
    }

    &.lancer-card-pilotgear {
      .lancer-card-header {
        border-bottom: 1.5rem solid #471016;
      }
      .lancer-card-body {
        background-color: #ede7e8;
      }
    }

    &.lancer-card-quickaction {
      .lancer-card-header {
        border-bottom: 1.5rem solid #68bd45;
      }
      .lancer-card-body {
        background-color: #e1f2da;
      }
    }

    &.lancer-card-reaction {
      .lancer-card-header {
        border-bottom: 1.5rem solid #0b7675;
      }
      .lancer-card-body {
        background-color: #e7f1f1;
      }
    }

    &.lancer-card-status {
      .lancer-card-header {
        border-bottom: 1.5rem solid #c75a00;
      }
      .lancer-card-body {
        background-color: #f9efe6;
      }
    }

    &.lancer-card-techaction {
      .lancer-card-header {
        border-bottom: 1.5rem solid #7e2477;
      }
      .lancer-card-body {
        background-color: #f2e9f1;
      }
    }

    &.lancer-card-weapon {
      .lancer-card-header {
        border-bottom: 1.5rem solid #000000;
      }
      .lancer-card-body {
        background-color: #f2f2f2;
      }
    }
  }
`;function me(e,t){let a=0;return e.replace(/\$/g,(e=>(a+=1,2===a?`#${t}$`:e)))}var ue,$e;!function(e){e.Core="C",e["No Room for a Wallflower"]="NRfaW",e["Operation Winter Scar"]="OWS",e["Operation Solstice Rain"]="OSR",e.Dustgrave="DG",e["Siren's Song: A Mountain's Remorse"]="SS:AMR",e["Shadow of the Wolf"]="SotW",e["The Long Rim"]="TLR",e["The Karrakin Trade Baronies"]="TKTB"}(ue||(ue={})),function(e){e.Attacks="attacks",e.Bonuses="bonuses",e.Combat="combat",e.Movement="movement",e.Pilot="pilot",e.Mech="mech",e["Full Action"]="fullAction",e["Quick Action"]="quickAction",e["Other Action"]="otherAction",e["Tech Action"]="techAction",e.Reaction="reaction",e.Harm="harm",e.Status="status",e.Condition="condition",e.Weapon="weapon",e["Pilot Gear"]="pilotGear",e.AI="ai",e.Gear="gear"}($e||($e={}));const ge={comp_con:`$${$e.AI}#comp_con$`,nhp:`$${$e.AI}#nhp$`,cascade:`$${$e.AI}#cascade$`,ai_control:`$${$e.AI}#ai_control$`},pe={movement:`$${$e.Combat}#movement$`,critical_hits:`$${$e.Combat}#critical_hits$`,range:`$${$e.Combat}#range$`,threat:`$${$e.Combat}#threat$`,line_of_sight:`$${$e.Combat}#line_of_sight$`,cover:`$${$e.Combat}#cover$`,soft_cover:`$${$e.Combat}#soft_cover$`,hard_cover:`$${$e.Combat}#hard_cover$`,invisibility:`$${$e.Combat}#invisibility$`,actions:`$${$e.Combat}#actions$`,full_action:`$${$e.Combat}#full_action$`,quick_action:`$${$e.Combat}#quick_action$`,other_action:`$${$e.Combat}#other_action$`,turn:`$${$e.Combat}#turn$`,round:`$${$e.Combat}#round$`,scene:`$${$e.Combat}#scene$`,action_resolution:`$${$e.Combat}#action_resolution$`,end_of_turn:`$${$e.Combat}#end_of_turn$`,end_of_next_turn:`$${$e.Combat}#end_of_next_turn$`,overcharge:`$${$e.Combat}#overcharge$`,reactions:`$${$e.Combat}#reactions$`,free_action:`$${$e.Combat}#free_action$`,attack:`$${$e.Combat}#attack$`,status:`$${$e.Combat}#status$`,condition:`$${$e.Combat}#condition$`,electronic_warfare:`$${$e.Combat}#electronic_warfare$`,skill_check:`$${$e.Combat}#skill_check$`,saves:`$${$e.Combat}#saves$`,contested_skill_check:`$${$e.Combat}#contested_skill_check$`},ye={accurate:`$${$e.Gear}#accurate$`,arcing:`$${$e.Gear}#arcing$`,armor_piercing:`$${$e.Gear}#armor_piercing$`,inaccurate:`$${$e.Gear}#inaccurate$`,knockback:`$${$e.Gear}#knockback$`,loading:`$${$e.Gear}#loading$`,ordnance:`$${$e.Gear}#ordnance$`,overkill:`$${$e.Gear}#overkill$`,overshield:`$${$e.Gear}#overshield$`,reliable_x:`$${$e.Gear}#reliable$`,seeking:`$${$e.Gear}#seeking$`,smart:`$${$e.Gear}#smart$`,threat_x:`$${$e.Gear}#threat_x$`,thrown_x:`$${$e.Gear}#thrown_x$`,deployable:`$${$e.Gear}#deployable$`,drone:`$${$e.Gear}#drone$`,grenade:`$${$e.Gear}#grenade$`,mine:`$${$e.Gear}#mine$`,mod:`$${$e.Gear}#mod$`,protocol:`$${$e.Gear}#protocol$`,shield:`$${$e.Gear}#shield$`,unique:`$${$e.Gear}#unique$`,ai:`$${$e.Gear}#ai$`,tags:`$${$e.Gear}#tags$`,limited_x:`$${$e.Gear}#limited_x$`},fe={damage:`$${$e.Harm}#damage$`,armor:`$${$e.Harm}#armor$`,resistance:`$${$e.Harm}#resistance$`,burn:`$${$e.Harm}#burn$`,explosive:`$${$e.Harm}#explosive$`,energy:`$${$e.Harm}#energy$`,kinetic:`$${$e.Harm}#kinetic$`,heat:`$${$e.Harm}#heat$`,bonus_damage:`$${$e.Harm}#bonus_damage$`,immunity:`$${$e.Harm}#immunity$`,damaging_objects:`$${$e.Harm}#damaging_objects$`,overheating:`$${$e.Harm}#overheating$`,reactor_meltdown:`$${$e.Harm}#reactor_meltdown$`,cooling:`$${$e.Harm}#cooling$`,overheating_table:`$${$e.Harm}#overheating_table$`,destroyed:`$${$e.Harm}#destroyed$`,printing:`$${$e.Harm}#printing$`},be={frame:`$${$e.Mech}#frame$`,mech_stats:`$${$e.Mech}#mech_stats$`,hp:`$${$e.Mech}#hp$`,structure:`$${$e.Mech}#structure$`,structure_damage_table:`$${$e.Mech}#structure_damage_table$`,repair_cap:`$${$e.Mech}#repair_cap$`,speed:`$${$e.Mech}#speed$`,evasion:`$${$e.Mech}#evasion$`,sensors:`$${$e.Mech}#sensors$`,tech_attack:`$${$e.Mech}#tech_attack$`,e_defense:`$${$e.Mech}#e_defense$`,heat_cap:`$${$e.Mech}#heat_cap$`,stress:`$${$e.Mech}#stress$`,save_target:`$${$e.Mech}#save_target$`,weapon:`$${$e.Mech}#weapon$`,systems:`$${$e.Mech}#systems$`,system_points:`$${$e.Mech}#system_points$`,core_power:`$${$e.Mech}#core_power$`,size:`$${$e.Mech}#size$`,repair:`$${$e.Mech}#repair$`,full_repair:`$${$e.Mech}#full_repair$`,rest:`$${$e.Mech}#rest$`,mounts:`$${$e.Mech}#mounts$`,main_mount:`$${$e.Mech}#main_mount$`,heavy_mount:`$${$e.Mech}#heavy_mount$`,aux_aux_mount:`$${$e.Mech}#aux_aux_mount$`,main_aux_mount:`$${$e.Mech}#main_aux_mount$`,flexible_mount:`$${$e.Mech}#flexible_mount$`,integrated_mount:`$${$e.Mech}#integrated_mount$`,superheavy_mount:`$${$e.Mech}#superheavy_mount$`},we={activate:`$${$e["Other Action"]}#activate$`,boot_up:`$${$e["Other Action"]}#boot_up$`,mount:`$${$e["Other Action"]}#mount$`,dismount:`$${$e["Other Action"]}#dismount$`,eject:`$${$e["Other Action"]}#eject$`,prepare:`$${$e["Other Action"]}#prepare$`,self_destruct:`$${$e["Other Action"]}#self_destruct$`,shut_down:`$${$e["Other Action"]}#shut_down$`,skill_check:`$${$e["Other Action"]}#skill_check$`},ke={mech_skills:`$${$e.Pilot}#mech_skills$`,pilot_mech_stats:`$${$e.Pilot}#pilot_mech_stats$`,hull:`$${$e.Pilot}#hull$`,agility:`$${$e.Pilot}#agility$`,systems:`$${$e.Pilot}#systems$`,engineering:`$${$e.Pilot}#engineering$`,grit:`$${$e.Pilot}#grit$`,talents:`$${$e.Pilot}#talents$`,triggers:`$${$e.Pilot}#triggers$`,pilot_actions:`$${$e.Pilot}#pilot_actions$`,fight:`$${$e.Pilot}#fight$`,jockey:`$${$e.Pilot}#jockey$`,reload:`$${$e.Pilot}#reload$`,license_level:`$${$e.Pilot}#license_level$`,core_bonuses:`$${$e.Pilot}#core_bonuses$`},ve={keywords:{comp_con:{name:"comp/con",page:`${ue.Core}:[107]`,category:"AI",text:`Comp/cons, also known as companion/concierge assistant units in full, are one of the types of AI used in the ${ye.ai} ${me(ye.tags,"tag")}. They're not quite sentient, but they're very advanced software suites. Unlike ${me(ge.nhp,"NHPs")} which have a personality, they're generally more like advanced chatbots, or search interfaces.`},nhp:{name:"NHP",page:`${ue.Core}:[107]`,category:"AI",text:`Unlike ${me(ge.comp_con,"comp/cons")}, Non-human personhood (NHP)s are actually sentient. Players can determine the general disposition and personality of the NHPs installed in their ${be.systems}, and whilst they're agreeable to commands, pilots have a very much conversational relationship with them.\nNHPs have to go through a lengthy process called 'shackling', to ensure these mysterious entities behave in a Human fashion, and actually have empathy for their pilots.\nShackled NHPs generally do not want to become unshackled, and aren't aware they're held in bondage. When they suffer physical trauma, they can become aware of this and cause a process called a ${ge.cascade}. NHPs are contained within the physical structure of a casket. When this is destroyed, the NHP is lost.`},cascade:{name:"Cascade",page:`${ue.Core}:[107]`,category:"AI",text:`Except for some limited systems - like ${me(ge.comp_con,"comp/cons")} - any time a mech with the ${ye.ai} ${me(ye.tags,"tag")} makes a ${be.structure} ${fe.damage} or ${fe.overheating} check, roll 1d20. On a 1, the NHP's casket has suffered a traumatic impact or code incursion, and enter a ${ge.cascade}.\nThe NHP becomes an NPC under the control of the GM, and gain their own agenda, or adopt one of several behavioural patterns. They will start ignoring their pilot, overruling their pilot, trying to get their pilot out of the way or simply acting outside the constraints of human logic and desire. \nNHPs in cascade can be stabilized by a pilot choosing to ${we.shut_down} their mech. This is the only action a pilot in a cascading mech can take.`},ai_control:{name:"handing over control",page:`${ue.Core}:[107]`,category:"AI",text:`Mechs can only have one system with the ${ye.ai} ${me(ye.tags,"tag")} installed at a time. If a mech has the ${ye.ai} ${me(ye.tags,"tag")}, its pilot can hand over control of the mech to the AI as a ${ye.protocol}, freeing the pilot to take other ${pe.actions}.\nThe AI acts on the same ${pe.turn} as the pilot, and doesn't benefit from the pilot's ${ke.talents} or other features, but otherwise behaves as normal.\nThe pilot can't use the mech to take any ${pe.actions} or ${pe.reactions} until they take control again, and can do so at the start of any subsequent turns as long as they are inside the mech.`}}},_e=($e.Bonuses,`$${$e.Bonuses}#accuracy$`),xe=`$${$e.Bonuses}#difficulty$`,Ce=`$${$e.Bonuses}#statistic_bonuses$`,Ae={melee_attack:`$${$e.Attacks}#melee_attack$`,ranged_attack:`$${$e.Attacks}#ranged_attack$`,tech_attack:`$${$e.Attacks}#tech_attack$`},Te={obstruction:`$${$e.Combat}#obstruction$`,adjacency:`$${$e.Combat}#adjacency$`,splitting_movement:`$${$e.Combat}#splitting_movement$`,engagement:`$${$e.Combat}#engagement$`,terrain:`$${$e.Combat}#terrain$`,lifting:`$${$e.Combat}#lifting$`,dragging:`$${$e.Combat}#dragging$`,jumping:`$${$e.Combat}#jumping$`,climbing:`$${$e.Combat}#climbing$`,falling:`$${$e.Combat}#falling$`,gravity:`$${$e.Combat}#gravity$`,flight:`$${$e.Combat}#flight$`,teleportation:`$${$e.Combat}#teleportation$`},Se=`$${$e.Status}#danger_zone$`,Ee=`$${$e.Status}#down_and_out$`,Ie=`$${$e.Status}#engaged$`,je=`$${$e.Status}#exposed$`,Pe=`$${$e.Status}#hidden$`,Me=`$${$e.Status}#invisible$`,qe=`$${$e.Status}#prone$`,Oe=`$${$e.Status}#shut_down$`,ze={keywords:{tech_attack:{name:"TECH ATTACK",page:`${ue.Core}:[64]`,category:"attacks",text:`The attacker chooses a target within their ${be.sensors} and ${pe.line_of_sight}, then makes a tech attack roll: rolling 1d20, plus ${Ae.tech_attack} and any ${_e} or ${xe}. To hit, they must match or beat the target’s ${be.e_defense}. \nTech attacks ignore ${pe.cover}.`},melee_attack:{name:"MELEE ATTACK",page:`${ue.Core}:[64]`,category:"attacks",text:`The attacker chooses a target within weapon ${pe.threat} and ${pe.line_of_sight}, then makes a melee attack roll: rolling 1d20 plus ${ke.grit} and any ${_e} or ${xe}. To hit, they must match or beat the target’s ${be.evasion}\nMelee attacks ignore ${pe.cover}.`},ranged_attack:{name:"RANGED ATTACK",page:`${ue.Core}:[64]`,category:"attacks",text:`The attacker chooses a target within their weapon ${pe.range} and ${pe.line_of_sight}, then makes a ranged attack roll: rolling 1d20, plus ${ke.grit} and any ${_e} or ${xe}. To hit, they must match or beat the target’s ${be.evasion}. \nCharacters that are ${me(Te.adjacency,"adjacent")} to hostile targets (and thus ${Ie}) take +1 ${xe} on all ranged attacks.\nWhen firing at targets in ${pe.soft_cover}, characters take +1 ${xe} on ranged attacks; ${pe.hard_cover} imposes +2 ${xe}.`}}},Re={keywords:{bonuses:{name:"BONUSES",page:`${ue.Core}:[13]`,category:"bonuses",text:`There are three kinds of bonuses that can be applied to rolls in Lancer. ${_e}, ${xe} & ${Ce}.`},accuracy:{name:"ACCURACY",page:`${ue.Core}:[13]`,category:"bonuses",text:`${_e} and ${xe} are temporary modifiers gained and lost in rapid, chaotic moments of action. Each point of ${_e} adds 1d6 to a roll, and is cancelled out by ${xe} at a 1:1 basis. If you are lucky enough to be rolling several accuracy dice, you do not add them together but instead take the highest result.`},difficulty:{name:"DIFFICULTY",page:`${ue.Core}:[13]`,category:"bonuses",text:`${_e} and ${xe} are temporary modifiers gained and lost in rapid, chaotic moments of action. Each point of ${xe} subtracts 1d6 from a roll, and is cancelled out by ${_e} at a 1:1 basis.`},statistic_bonuses:{name:"STATISTIC BONUSES",page:`${ue.Core}:[13]`,category:"bonuses",text:`Statistic Bonuses depend on the type of roll you are making, and come from three sources: your pilot's ${ke.triggers}, your pilot's ${ke.mech_skills} & their ${ke.grit}. Each roll can only benefit from one of these at a time, and you'll find which one each roll uses in the description of the roll in question.`}}},He=`$${$e.Condition}#immobilized$`,We=`$${$e.Condition}#impaired$`,Ne=`$${$e.Condition}#jammed$`,Ue=`$${$e.Condition}#lock_on$`,Le=`$${$e.Condition}#shredded$`,Ye=`$${$e.Condition}#slowed$`,Ge=`$${$e.Condition}#stunned$`,Be=`$${$e["Full Action"]}#barrage$`,Fe=`$${$e["Full Action"]}#disengage$`,De=`$${$e["Full Action"]}#full_tech$`,Xe=`$${$e["Full Action"]}#improvised_attack$`,Ke=`$${$e["Full Action"]}#stabilize$`,Ve=`$${$e["Quick Action"]}#boost$`,Qe=`$${$e["Quick Action"]}#grapple$`,Je=`$${$e["Quick Action"]}#hide$`,Ze=`$${$e["Quick Action"]}#quick_tech$`,et=`$${$e["Quick Action"]}#ram$`,tt=`$${$e["Quick Action"]}#search$`,at=`$${$e["Quick Action"]}#skirmish$`,ot=`$${$e.Reaction}#brace$`,nt=`$${$e.Reaction}#overwatch$`,rt={size:`$${$e.Weapon}#size$`,type:`$${$e.Weapon}#type$`,damage:`$${$e.Weapon}#damage$`,auxiliary:`$${$e.Weapon}#auxiliary$`,superheavy:`$${$e.Weapon}#superheavy$`,main:`$${$e.Weapon}#main$`,heavy:`$${$e.Weapon}#heavy$`,melee:`$${$e.Weapon}#melee$`,cqb:`$${$e.Weapon}#cqb$`,rifle:`$${$e.Weapon}#rifle$`,launcher:`$${$e.Weapon}#launcher$`,cannon:`$${$e.Weapon}#cannon$`,nexus:`$${$e.Weapon}#nexus$`,patterns:`$${$e.Weapon}#patterns$`},st={keywords:{movement:{name:"movement",page:`${ue.Core}:[62]`,category:"combat",text:`On their turn, characters can always move spaces equal to their ${be.speed}, in addition to any other ${pe.actions} including ${Te.splitting_movement}. This is called a standard move to distinguish it from movement granted by ${be.systems} or ${ke.talents}.\nA character only counts as moving if they move 1 or more spaces. Characters can move into any adjacent space, even diagonally, as long as the space isn’t occupied by an ${Te.obstruction} (and is one that they would be able to move in – characters can't move straight up unless they can use ${Te.flight}, for example).`},critical_hits:{name:"critical hits",page:`${ue.Core}:[64]`,category:"combat",text:`A 20+ on a melee or ranged attack causes a ${me(pe.critical_hits,"critical hit")}. On a critical hit, all damage dice are rolled twice (Including bonus damage) and the highest result from each source of ${fe.damage} is used.\nFor example, if a player got a critical hit on an attack that would normally deal 2d6 ${fe.damage}, they would instead roll 4d6 and pick the two highest results.`},range:{name:"range",page:`${ue.Core}:[64]`,category:"combat",text:`Range is measured from any edge of the attacking character. Target must be inside the range to be valid targets. Some weapons have ${me(rt.patterns,"attack patterns")}, which will supersede range unless the weapon also has a range.\nIf the weapon has a ${me(rt.patterns,"attack pattern")} & a range, the attack's origin point can be drawn from any point within the specified range & ${pe.line_of_sight}`},threat:{name:"threat",page:`${ue.Core}:[64]`,category:"combat",text:`Threat is the maximum range at which a ${me(rt.melee,"melee weapon")} can be used, and at which both melee and ranged weapons can be used for ${nt}.\n${pe.threat}, like ${pe.range}, is measured from the edge of a character, so larger mechs cover slightly more area than smaller mechs.\nUnless noted otherwise, all weapons default to 1 threat, which can be increased with some talents and gear.`},line_of_sight:{name:"line of sight",page:`${ue.Core}:[65]`,category:"combat",text:`Characters can only ${pe.attack} or take ${me(pe.actions,"action")} against targets that they can see, at least partially. If it's not possible to trace a line to some part of the target - perhaps because it's completely blocked by ${pe.cover} or ${Te.terrain} - then they can't be attacked.\nLine of sight doesn't imply visibility alone, but also a clear path for your attack. Even if you can somehow see a target behind a solid wall (using a remote drone, for example), you can't attack targets within. Weapons with the ${ye.arcing} or ${ye.seeking} ${ye.tags} offer ways around this.`},cover:{name:"cover",page:`${ue.Core}:[66]`,category:"combat",text:`Two types of cover are always relevant in combat: ${pe.soft_cover} & ${pe.hard_cover}.\nCharacters can only benefit from one type of cover at a time, their benefits don't stack. Unless specified, characters never grant cover to objects or other characters. Some mechs have abilities that allow them to provide cover, such as the guardian trait.\nCharacters can shoot over cover or objects smaller or the same ${be.size} as themselves without difficulty. Objects can also be ${me(fe.damaging_objects,"destroyed")} to remove their cover.`},soft_cover:{name:"soft cover",page:`${ue.Core}:[66]`,category:"combat",text:`Soft cover includes smoke, foliage, trees, blinding light, dust clouds, low hills, and low walls. Anything that isn't reliable to block enemy fire, but does provide visual interference or profile reduction sufficient to make aiming difficult. Any time a target is obscured or obstructed somehow, it has soft cover, adding +1 ${xe} to any ranged attacks. If the cover is the same ${be.size} as them, they can still shoot over, through or around it without penalty.`},hard_cover:{name:"hard cover",page:`${ue.Core}:[66]`,category:"combat",text:`Hard cover includes ruined buildings, tall walls, bulkheads, reinforced emplacements and ${fe.destroyed} mechs and vehicles. Hard cover is solid enough to block shots and hide behind and adds +2 ${xe} to any ranged attacks. Characters can only benefit from hard cover if they are ${me(Te.adjacency,"adjacent")} to whatever they are hiding behind, and are the same ${be.size} or smaller. If the cover is the same ${be.size} as them, they can still shoot over, through or around it without penalty.`},invisibility:{name:"invisibility",page:`${ue.Core}:[65]`,category:"combat",text:`Some characters can turn invisible. Invisible characters can still be seen or detected by heat patterns and some visual artifacts, but they are extremely hard to target. All attacks, regardless of ${rt.type} have a 50% chance to miss outright, before an attack roll is made. Flip a coin or roll a die to determine if the attack misses.\nAdditionally, invisible characters can always ${Je}, even without cover.`},actions:{name:"actions",page:`${ue.Core}:[68]`,category:"combat",text:`Characters can take two ${me(pe.quick_action,"quick actions")} or one ${pe.full_action} on their turn.\nCharacters cannot perform the same action more than once in a ${pe.turn}, except as a ${pe.free_action} or ${me(pe.reactions,"reaction")}. For example, if a character gains ${Ve} as a free action from one of their ${be.systems}, they could ${Ve} as their normal ${pe.quick_action} and then ${Ve} again as a ${pe.free_action}. Alternatively, a character could also ${pe.overcharge} to gain a second ${Ve} as a free action.\nSee also ${pe.action_resolution} for how to clear up any confusion about when an action resolves.`},full_action:{name:"full action",page:`${ue.Core}:[61]`,category:"combat",text:`${pe.actions} that require full attention, e.g. firing a complex weapon. Characters have the following full actions available:\n      \n${Be}\n      \n${Fe}\n      \n${De}\n      \n${Xe}\n      \n${Ke}`},quick_action:{name:"quick action",page:`${ue.Core}:[61]`,category:"combat",text:`Actions that take a few moments, such as quickly firing a weapon, activating a system, or moving further. Characters have the following quick actions available:\n      \n${Ve}\n      \n${Qe}\n      \n${Je}\n      \n${Ze}\n      \n${et}\n      \n${tt}\n      \n${at}`},other_action:{name:"other action",page:`${ue.Core}:[71]`,category:"combat",text:`Actions that are either not directly applicable to combat, or otherwise uncommonly used. Characters have the following other actions available:\n      \n${we.activate}\n      \n${we.boot_up}\n      \n${we.mount}\n      \n${we.dismount}\n      \n${we.eject}\n      \n${we.prepare}\n      \n${we.self_destruct}\n      \n${we.shut_down}\n      \n${we.skill_check}`},turn:{name:"turn",page:`${ue.Core}:[60]`,category:"combat",text:`Mech combat is divided into turns and ${me(pe.round,"rounds")}. Each character takes one turn per ${pe.round} unless otherwise specified. Turns represent activity, not the passing of time. Even though characters act in a certain order, the turns in each ${pe.round} are assumed to occur narratively at roughly the same time.\nTurn order is decided alternatively by players & the GM. The players collectively decide which player or ally goes first, then the GM decides which enemy goes next, then the last player decides which player or ally goes next, and so on. The side with characters remaining take their turns in an order decided by the GM or players, as relevant.\nSee also:\n      \n${pe.end_of_turn}\n      \n${pe.end_of_next_turn}`},round:{name:"round",page:`${ue.Core}:[60]`,category:"combat",text:`Mech combat is divided into ${me(pe.turn,"turns")} and rounds. Players will always take the first turn in the first round, but in subsequent rounds whoever goes first is the opposite of who took the last ${pe.turn} in the previous round. If the last ${pe.turn} was a friendly mech, the next round will be started by an enemy combatant.`},scene:{name:"scene",page:`${ue.Core}:[14]`,category:"combat",text:`A scene is a period of continuous dialogue, action, or activity that has a discrete starting and stopping point. This is called a scene because it's helpful to think about it in cinematic terms: as long as the focus (or 'camera') is on the players and their action, a scene is happening. When the focus cuts away from the current scene, or the current action naturally ends, that's when the scene should end too.\n      \nIn practical terms, when a ${be.weapon}, ${me(be.systems,"system")}, or ${ke.talents} say they can be used 1/scene, that generally means they can be used once per combat. If a scene ends and a new combat scene starts, the character can use that weapon, system, or talent again.`},action_resolution:{name:"action resolution",page:`${ue.Core}:[68]`,category:"combat",text:`If there's any uncertainty about when certain ${pe.actions} or effects take place or resolve, effects caused by other characters always resolve first during a character's ${pe.turn}. If, for example, a character starts their ${pe.turn} in a zone created by another character that causes them to take ${fe.damage} - this resolves before any other effects or ${pe.actions} take place.\nOtherwise, characters can always choose the resolution order of actions or effects that they take on their ${pe.turn}. If there were, in the above example, two zones, the player gets to pick the order. If there's still uncertainty, the GM has the final say.`},end_of_turn:{name:"end of turn",page:`${ue.Core}:[68]`,category:"combat",text:`Effects and activities that take place at the end of a character's ${pe.turn} occur after any standard ${me(pe.movement,"moves")} and ${pe.actions} (including ${me(pe.free_action,"free actions")} and ${pe.overcharge}) have resolved, but before the next character starts their ${pe.turn}.\nIf a character is using multiple effects that take place at the end of their ${pe.turn}, their player chooses the order in which they trigger.`},end_of_next_turn:{name:"end of next turn",page:`${ue.Core}:[68]`,category:"combat",text:`Effects that last until the end of a character's next ${pe.turn} persist until the next ${pe.turn} they have in the ${pe.turn}, not the current ${pe.turn} - even if it is their ${pe.turn} when they receive the effect.`},overcharge:{name:"overcharge",page:`${ue.Core}:[73]`,category:"combat",text:`Once per ${pe.turn} you can overcharge your mech, allowing you to make any ${pe.quick_action} as if it were a ${pe.free_action} - even ${pe.actions} you have already taken this ${pe.turn}.\nThe first time you overcharge, take 1 ${fe.heat} ${fe.damage}. \nThe second time, you take 1d3 ${fe.heat} ${fe.damage}.\nThe third time, you take 1d6 ${fe.heat} ${fe.damage}, and any subsequent times you take 1d6+4 ${fe.heat} ${fe.damage}.\nA ${be.full_repair} resets this counter.`},reactions:{name:"reactions",page:`${ue.Core}:[61]`,category:"combat",text:`Reactions are special ${pe.actions} that can be made outside of the usual ${pe.turn} order as responses to incoming ${me(pe.attack,"attacks")}, enemy ${pe.movement}, and other events. \nEach reaction can only be used a certain number of times per round, and a character can take only one reaction per ${pe.turn} (Their ${pe.turn} or that of another character), but there is no limit to how many reactions can be taken, overall.\n      \nOutside of reactions provided by ${be.systems}, ${ke.talents}, ${me(be.weapon,"weapons")} or other sources, each mech has access to two default reactions:\n      \n${ot}\n      \n${nt}\n      \nAs well as the ability to create reactions via the ${we.prepare} ${pe.quick_action}.\n      \nUnless specified otherwise, reactions resolve after the activity that triggered them.`},free_action:{name:"free action",page:`${ue.Core}:[61]`,category:"combat",text:`Free actions are special ${pe.actions} granted by character traits, like mech ${be.systems} or pilot ${ke.talents}. Characters can take free actions at any point during their ${pe.turn}, and they don't count towards the number of ${me(pe.quick_action,"quick")} or ${me(pe.full_action,"full")} actions they take.\nThey can also be used to take ${pe.actions} more than once per ${pe.turn}. For example, if a character can ${Ve} as a free action, they can do so even if they have already used ${Ve} in the same turn.`},attack:{name:"attack",page:`${ue.Core}:[64]`,category:"combat",text:`Mechs can attack using the ${at}, ${Be}, ${Ze}, ${De} and ${Xe} ${pe.actions}. Characters on foot attack using the ${ke.fight} action. Whichever action is taken, the details of the attack are determined by the ${be.weapon} or ${be.systems} that are used.\n      \nThere are three types of attack in mech combat:\n      \n${me(Ae.melee_attack,"melee")}, ${me(Ae.ranged_attack,"ranged")}, and ${me(Ae.tech_attack,"tech")}.`},status:{name:"status",page:`${ue.Core}:[77]`,category:"combat",text:`During combat, characters often inflict and receive statuses and ${me(pe.condition,"conditions")}Statuses are usually effects that can't easily be cleared. ${pe.actions}, ${ke.talents}, ${be.systems} and other effects can all inflict statuses. The source descriptions indicate how long they last. If a status says it lasts until the ${pe.end_of_next_turn} but is inflicted during a character's ${pe.turn}, it lasts until the end of their next ${pe.turn}.\n      \nNot every status is negative, some are entirely beneficial.\n      \nThe following statuses exist:\n      \n${Se}\n      \n${Ee}\n      \n${Ie}\n      \n${je}\n      \n${Pe}\n      \n${Me}\n      \n${qe}\n      \n${Oe}`},condition:{name:"condition",page:`${ue.Core}:[77]`,category:"combat",text:`During combat, characters often inflict and receive ${me(pe.status,"statuses")} and conditions. Conditions are generally temporary effects caused by things like ${fe.damage} & ${pe.electronic_warfare}. ${pe.actions}, ${ke.talents}, ${be.systems} and other effects can all inflict conditions. The source descriptions indicate how long they last. If a condition says it lasts until the ${pe.end_of_next_turn} but is inflicted during a character's ${pe.turn}, it lasts until the end of their next ${pe.turn}.\n      \n${Ke} clears many of these condition.\n      \nThe following conditions exist:\n      \n${He}\n      \n${We}\n      \n${Ne}\n      \n${Ue}\n      \n${Le}\n      \n${Ye}\n      \n${Ge}`},electronic_warfare:{name:"electronic warfare",page:`${ue.Core}:[-]`,category:"combat",text:`Although electronic warfare is not a keyword, it is a common term within the core book. Electronic warfare generally means any ${me(pe.actions,"action")} taken that results in a ${Ae.tech_attack} or otherwise impairs a mech's ${be.systems}. Mechs attempting to hack and take down other mechs systems.\nSee also ${De}, ${Ze}, ${je} & ${Ne}.`},skill_check:{name:"skill check",page:`${ue.Core}:[13]`,category:"combat",text:`When the book calls for a skill check, such as by calling for a ${ke.agility} check, you roll a d20, add the relevant ${me(ke.mech_skills,"skill")} modifier as well as any modifiers if the skill check is difficult or risky and see if the result is a 10 or higher. On 10+, you succeed, on 9 or less, you fail. Outside of built-in skill checks, there is also the ${we.skill_check} ${pe.full_action}, if you want to do an action in mech combat that might not have a ${pe.actions} equivelant.\n      \nAnd remember, you are always allowed to skip the dice and choose to fail!`},saves:{name:"saves",page:`${ue.Core}:[13]`,category:"combat",text:`Saves are rolls made to avoid or resist negative effects in mech combat. To save, roll a d20 and add any bonuses (such as from your ${ke.mech_skills}), then compare the result to the target number. This target number will differ depending on the source of the save, if you equal or exceed this number, you succeed; if your roll is lower, you fail.`},contested_skill_check:{name:"contested skill check",page:`${ue.Core}:[13]`,category:"combat",text:`In a contested check, both sides roll a ${pe.skill_check} and add any bonuses. Whoever has the highest results win. If the result is a tie, the attacker - the one who initiated the contest - wins.\n      \nYou might make contested checks in both narrative play and mech combat.`}}},it={bolster:`$${$e["Tech Action"]}#bolster$`,scan:`$${$e["Tech Action"]}#scan$`,lock_on:`$${$e["Tech Action"]}#lock_on$`,invade:`$${$e["Tech Action"]}#invade$`,fragment_signal:`$${$e["Tech Action"]}#fragment_signal$`,tech_actions:`$${$e["Tech Action"]}#tech_actions$`},ct={keywords:{immobilized:{name:"immobilized",page:`${ue.Core}:[78]`,category:"condition",text:`Immobilized characters cannot make any ${me(pe.movement,"voluntary movement")}, although involuntary movements (such as being ${et}) are unaffected.`},impaired:{name:"impaired",page:`${ue.Core}:[78]`,category:"condition",text:`Impared characters receive a +1 ${xe} on all ${me(pe.attack,"attacks")}, ${pe.saves}, and ${me(pe.skill_check,"skill checks")}.`},jammed:{name:"jammed",page:`${ue.Core}:[78]`,category:"condition",text:`Jammed character's can't:\n      \nUse comms to talk to other characters;\n      \nMake ${me(pe.attack,"attacks")}, other than ${Xe}, ${Qe}, and ${et};\n      \nTake ${pe.reactions}, or take or benefit from ${it.tech_actions}.`},lock_on:{name:"lock on",page:`${ue.Core}:[78]`,category:"condition",text:`Hostile characters can choose to consume a character's Lock On ${pe.condition} in exchange for +1 ${_e} on their next ${pe.attack} against that character.\n      \nLock On is also required to use some ${ke.talents} & ${be.systems}.`},shredded:{name:"shredded",page:`${ue.Core}:[78]`,category:"condition",text:`Shredded characters don't benefit from ${fe.armor} or ${fe.resistance}.`},slowed:{name:"slowed",page:`${ue.Core}:[78]`,category:"condition",text:`The only move slowed characters can make is their standard ${me(pe.movement,"move")}, on their own turn - they can't ${Ve} or make special moves granted by ${ke.talents}, ${be.systems}, or ${me(be.weapon,"weapons")}.`},stunned:{name:"stunned",page:`${ue.Core}:[78]`,category:"condition",text:`Stunned mechs cannot ${pe.overcharge}, ${me(pe.movement,"move")} or take any ${pe.actions} - including ${me(pe.free_action,"free actions")} and ${pe.reactions}. Pilots can still ${we.mount}, ${we.dismount}, and ${we.eject} from mechs and can take actions normally.\n      \nStunned mechs have a maximum of 5 ${be.evasion}, and automatically fail all ${ke.hull} and ${ke.agility} ${me(pe.skill_check,"checks")} and ${pe.saves}.`}}},ht={keywords:{barrage:{name:"barrage",page:`${ue.Core}:[71]`,category:"full action",text:`When you barrage, you ${pe.attack} with two ${me(be.weapon,"weapons")}, or with one ${rt.superheavy} ${be.weapon}.\n      \nTo barrage, choose your ${be.weapon} and either one target or different targets - within ${pe.range} - then make an ${pe.attack} with each ${be.weapon}.\n      \nIn addition to your primary ${me(pe.attack,"attacks")}, you may also attack with an ${rt.auxiliary} ${be.weapon} on each mount that was fired, so long as the ${rt.auxiliary} ${be.weapon} hasn't yet been fired this ${me(pe.actions,"action")}.\n      \n${rt.superheavy} ${me(be.weapon,"weapons")} can only be fired as part of a barrage.`},disengage:{name:"disengage",page:`${ue.Core}:[71]`,category:"full action",text:`When you disengage, you attempt to extricate yourself safely from a dangerous situation, make a steady and measured retreat, or rely on your mech's agility to slip in and out of threat ranges faster than an enemy can strike.\n      \nUntil the end of your current ${pe.turn}, you ignore ${Te.engagement} and your ${pe.movement} does not provoke ${pe.reactions}.`},full_tech:{name:"full tech",page:`${ue.Core}:[71]`,category:"full action",text:`When you use full tech, you perform multiple ${it.tech_actions} or a single, more complex action.\n      \nTo use full tech, choose two ${Ze} options or a single ${me(be.systems,"system")} or tech option that requires full tech to activate. If you choose two ${Ze} options, you can choose the same option multiple times.`},improvised_attack:{name:"improvised attack",page:`${ue.Core}:[71]`,category:"full action",text:`When you make an improvised attack, you attack with a rifle butt, fist, or another improvised melee weapon. You can use anything from the butt of a ${be.weapon} to a slab of concrete or a length of hull plating - the flavor of the attack is up to you!\n      \nTo make an improvised attack, make a ${Ae.melee_attack} against an ${me(Te.adjacency,"adjacent")} target. On success they take 1d6 ${fe.kinetic} ${fe.damage}.`},stabilize:{name:"stabilize",page:`${ue.Core}:[71]`,category:"full action",text:`When you stabilize, you enact emergency protocols to purge your mech's ${be.systems} of excess ${fe.heat}, ${be.repair} your chassic where you can, or eliminate hostile code.\n      \nTo stabilize, choose one of the following:\n      \nCool your mech, clearing all ${fe.heat} and ${je}.\n      \nMark 1 ${be.repair} to restore all ${be.hp}.\n      \nAdditionally, choose one of the following:\n      \nReload all ${ye.loading} ${me(be.weapon,"weapons")}.\n      \nClear any ${fe.burn} currently affecting your mech.\n      \nClear a ${pe.condition} that wasn't caused by your own ${be.systems}, ${ke.talents}, etc.\n      \nClear an ${me(Te.adjacency,"adjacent")} allied character's ${pe.condition} that wasn't caused by one of their own ${be.systems}, ${ke.talents}, etc.`}}},lt={keywords:{accurate:{name:"accurate",page:`${ue.Core}:[105]`,category:"gear",text:`${me(pe.attack,"Attacks")} made with this ${be.weapon} receive +1 ${_e}.`},arcing:{name:"arcing",page:`${ue.Core}:[105]`,category:"gear",text:`This ${be.weapon} can be fired over obstacles, usually by lobbing a projectile in an arc. ${me(pe.attack,"Attacks")} made with this ${be.weapon} don't require ${pe.line_of_sight}, as long as it's possible to to trace a path to the target; however, they are still affected by ${pe.cover}.`},armor_piercing:{name:"armor piercing",page:`${ue.Core}:[105]`,category:"gear",text:`Damage dealt by this ${be.weapon} ignores ${fe.armor}.`},inaccurate:{name:"inaccurate",page:`${ue.Core}:[105]`,category:"gear",text:`Attacks made with this weapon receive +1 ${xe}.`},knockback:{name:"knockback",page:`${ue.Core}:[105]`,category:"gear",text:`On a hit, the user may choose to knock their target X spaces in a straight line directly away from the point of origin. (e.g. the attacking mech, or the center of a ${me(rt.patterns,"blast")})). Multiple knockback effects stack with each other. This means that an ${pe.attack} made with a knockback 1 ${be.weapon} and a ${me(ke.talents,"talent")} that grants knockback 1 counts as having knockback 2.`},loading:{name:"loading",page:`${ue.Core}:[105]`,category:"gear",text:`This ${be.weapon} must be reloaded after each use. Mechs can reload with ${Ke} and some ${be.systems}.`},ordnance:{name:"ordnance",page:`${ue.Core}:[105]`,category:"gear",text:`This ${be.weapon} can only be fired before the user ${me(pe.movement,"moves")} or takes any other ${pe.actions} on their turn, excepting ${me(ye.protocol,"protocols")}. The user can still act and ${me(pe.movement,"moves")} normally after attacking. Additionally, because of its size, this ${be.weapon} can't be used against targets in ${Te.engagement} with the user's mech, and cannot be used for ${nt}.`},overkill:{name:"overkill",page:`${ue.Core}:[105]`,category:"gear",text:`When rolling for damage with this ${be.weapon}, any damage dice that land on a 1 cause the attacker to take 1 ${fe.heat}, and are then rerolled. Additional 1s continue to trigger this effect.`},overshield:{name:"overshield",page:`${ue.Core}:[105]`,category:"gear",text:`This ${me(be.systems,"system")} provides ${be.hp} that disappears at the end of the ${pe.scene} or when a specified condition is met. The user only retains the highest value of overshield applied - it does not stack.\n      \nFor example, if a ${me(be.systems,"system")} provides overshield 5 and the user gains another effect that provides overshield 7, they would gain overshield 7. Damage is dealt to overshield first, then ${be.hp}. \nOvershield can push a character past their maximum ${be.hp}. It can't benefit from any ${me(be.repair,"healing")} but otherwise benefits normally from anything that would affect ${be.hp} and ${fe.damage} (i.e., ${fe.resistance}, ${fe.armor}, etc).`},reliable_x:{name:"reliable x",page:`${ue.Core}:[105]`,category:"gear",text:`This ${be.weapon} has some degree of self-correction or is simply powerful enough to cause ${fe.damage} when with a glancing blow. It always does X ${fe.damage}, even if it misses its target or rolls less ${fe.damage}. Reliable ${fe.damage} inherits other ${ye.tags} (such as ${ye.armor_piercing}) and base ${fe.damage} ${rt.type} but not ${ye.tags} that require a hit, such as ${ye.knockback}.`},seeking:{name:"seeking",page:`${ue.Core}:[105]`,category:"gear",text:`This ${be.weapon} has a limited form of self-guidance and internal propulsion, allowing it to follow complicated paths to its target. As long as it's possible to draw a path to its target, this ${be.weapon} ignores ${pe.cover} and doesn't require ${pe.line_of_sight}.`},smart:{name:"smart",page:`${ue.Core}:[105]`,category:"gear",text:`This ${be.weapon} has a self-guidance system, self-propelled projectiles, or even nanorobotic ammunition. These systems are effective enough that its attacks can't simply be dodged - they must be scrambled or jammed. Because of this, all attacks with this weapon - including ${me(Ae.melee_attack,"melee")} and ${me(Ae.ranged_attack,"ranged")} attacks - use the target's ${be.e_defense} instead of ${be.evasion}. Targets with no ${be.e_defense} count as having 8 ${be.e_defense}.`},threat_x:{name:"threat x",page:`${ue.Core}:[105]`,category:"gear",text:`This ${be.weapon} can be used to make ${nt} within X spaces. If it's a ${rt.melee} ${be.weapon}, it can be used to make ${me(Ae.melee_attack,"melee attacks")} within X spaces.`},thrown_x:{name:"thrown x",page:`${ue.Core}:[105]`,category:"gear",text:`This ${rt.melee} ${be.weapon} can be thrown at targets within X spaces. Thrown attacks follow the rules for ${me(Ae.melee_attack,"melee attacks")} but are affected by ${pe.cover}; additionally, a thrown ${be.weapon} comes to rest in an adjacent space to its target and must be retrieved as a ${pe.free_action} while adjacent to that ${be.weapon} before it can be used again.`},deployable:{name:"deployable",page:`${ue.Core}:[105]`,category:"gear",text:`This system is an object that can be deployed on the field. Unless otherwise specified, it can be deployed in adjacent, free and valis space as a ${pe.quick_action}, and has 5 ${be.evasion} and 10 ${be.hp} per ${be.size}.`},drone:{name:"drone",page:`${ue.Core}:[105]`,category:"gear",text:`This is a self-propelled, semi-autonomous unit with rudimentary intelligence. Unless otherwise specified, drones are ${be.size} 1/2 characters that are allied to the user and have 10 ${be.evasion}, 5 ${be.hp} and 0 ${fe.armor}.\n      \nTo be used, they must be deployed to a free, valid space within ${be.sensors} and ${pe.line_of_sight}, typically as a ${pe.quick_action}. Once deployed, they can be recalled with the same action used to deploy them (${pe.quick_action} or ${pe.full_action}, etc.), rejoining with your mech.\n      \nBy default, drones can't take ${pe.actions} or ${me(pe.movement,"move")}; if they do have ${pe.actions} or ${pe.movement}, they act on their user's turn. They benefit from ${pe.cover} and other defenses as usual, and make all mech ${me(pe.skill_check,"skill checks")} and ${pe.saves} at +0.\n      \nIf a drone reaches 0 ${be.hp} it is destroyed and must be repaired before it can be used again - like any system. As long as the drone hasn't been destroyed, it is restored to full ${be.hp} when the user rests or performs a ${be.full_repair}. Deployed drones persist for the rest of the full ${pe.scene}, until destroyed or until otherwise specified.`},grenade:{name:"grenade",page:`${ue.Core}:[106]`,category:"gear",text:`As a ${pe.quick_action}, this explosive or other device can be thrown to a space within ${pe.line_of_sight} and the specified ${pe.range}.`},mine:{name:"mine",page:`${ue.Core}:[106]`,category:"gear",text:`As a ${pe.quick_action}, this device can be planted in an adjacent, free and valid space on any surface, but not adjacent to any other mines. Upon deployment, it arms at the ${me(pe.end_of_turn,"end of the deploying character's turn")} and - unless otherwise specified - is triggered when any character enters an adjacent space. Characters leaving an adjacent space will not trigger a mine. \n      \nOnce triggered, a mine creates a ${me(rt.patterns,"burst")} attack starting from the space in which it was placed. Mines within a character's ${be.sensors} can be detected by making a successful ${ke.systems} ${me(pe.skill_check,"check")} as a ${pe.quick_action}, otherwise they are ${Pe} and can't be targeted. \n      \nDetected mines can be disarmed from adjacent spaces by making a succesful ${ke.systems} ${me(pe.skill_check,"check")} as a ${pe.quick_action}; the attempt takes place before the mine detonates, and on a failure, the mine detonates as normal.`},mod:{name:"mod",page:`${ue.Core}:[106]`,category:"gear",text:`This modification can be applied to a ${be.weapon}. Each ${be.weapon} can only have one mod at a time, and cannot have more than one of the same mod. Mods are applied when the user builds their mech, or during a ${be.full_repair}`},protocol:{name:"protocol",page:`${ue.Core}:[106]`,category:"gear",text:`This ${me(be.systems,"system")} can be activated as a ${pe.free_action}, but only at the start of the user's ${pe.turn}. Another ${me(pe.actions,"action")} might be needed to deactivate it.`},shield:{name:"shield",page:`${ue.Core}:[106]`,category:"gear",text:`This ${me(be.systems,"system")} is an energy shield of some kind.`},unique:{name:"unique",page:`${ue.Core}:[106]`,category:"gear",text:`This ${be.weapon} or ${me(be.systems,"system")} cannot be duplicated - each character can only have one copy of it installed at a time.`},ai:{name:"ai",page:`${ue.Core}:[105]`,category:"gear",text:`A mech can only have one ${me(be.systems,"system")} with this ${me(ye.tags,"tag")} installed at a time. Some AI ${be.systems} grant the ${me(ye.tags,"tag")} tag to the mech. \nA mech with the AI ${me(ye.tags,"tag")} has an ${ge.nhp} or ${ge.comp_con} unit installed that can act somewhat autonomously. A pilot can choose to ${me(ge.ai_control,"hand over the controls")} to their AI or take control back as a ${ye.protocol}.\n      \nTheir mech gains its own set of ${pe.actions} and ${pe.reactions} when controlled by an AI, but the pilot can't take any ${pe.actions} or ${pe.reactions} with it until the start of their next turn. AIs can't benefit from ${ke.talents}, and have a small chance of ${me(ge.cascade,"cascading")} when they take ${be.structure} ${fe.damage} or ${be.stress} ${fe.damage}.`},tags:{name:"tags",page:`${ue.Core}:[104]`,category:"gear",text:`Tags are a specific term that describe how a piece of gear functions and what sort of rules are attached to it.\n      \nWhere a tag of any type is followed by X, X is the relevant quantity (e.g., ${fe.armor}, ${fe.damage}, ${pe.range}, etc).\n      \nRemember that specific rules override general rules. That means that if a ${me(be.systems,"system")} has different rules to what the general rules say, you should use the specific rules given for that ${me(be.systems,"system")}.`},limited_x:{name:"limited x",page:`${ue.Core}:[105]`,category:"gear",text:`This ${be.weapon} or ${me(be.systems,"system")} can only be used X times before it requires a ${be.full_repair}. Some limited ${be.systems}, like ${me(ye.grenade,"grenades")}, describe these uses as "charges". To use the system, the user expends a charge.`}}},dt={keywords:{damage:{name:"damage",page:`${ue.Core}:[67]`,category:"harm",text:`Every pilot hopes to avoid as much enemy fire as possible, but they know this truth: sooner or later someone's going to punch a few holes in your kit.\n      \nThere are four types of damage pilots need to reckon with: ${fe.explosive}, ${fe.energy}, ${fe.kinetic}, and ${fe.burn}, each representing a different sort of weapon or projectile.\n      \nWhen an attacker has succefully landed an ${pe.attack}, the total damage is calculated in the following order:\n      \n1. The attacker rolls damage, and applies any relevant reductions or increases (such as the doubling from the ${je} status).\n      \n2. The target's ${fe.armor} is subtracted from the total.\n      \n3. Any other deductions from the defender are subtracted from the remaining damage. This includes any reductions from ${fe.resistance}, and any relevant ${be.systems}, ${ke.talents}, or ${pe.reactions}.\n      \n4. Remaining damage is subtracted from the target's ${be.hp}.`},armor:{name:"armor",page:`${ue.Core}:[67]`,category:"harm",text:`Armor reduces all incoming ${fe.damage} from a single source by an equal amount to its rating, which goes from 1-4; however, ${ye.armor_piercing} ${me(be.weapon,"weapons")} and ${fe.bonus_damage} ignore armor altogether.`},resistance:{name:"resistance",page:`${ue.Core}:[67]`,category:"harm",text:`Characters with resistance to a specific type of ${fe.damage} reduce all incoming damage of that type by half. Characters can only have reistance once per type of ${fe.damage} - it doesn't stack.`},burn:{name:"burn",page:`${ue.Core}:[67]`,category:"harm",text:`Pilots need to worry about more than just bullet holes on the battlefield. Some weapons deal ${fe.burn} (damage over time). Burn might represent flames, searing plasma, acid or something more insidious, like a swarm of greywash nanites.\n      \nWhen characters take ${fe.burn}, it has two effects: first, they immediately take ${fe.burn} ${fe.damage}, ignoring ${fe.armor}, and then they mark down the ${fe.burn} they just took on their sheet. At the end of their turn, characters with ${fe.burn} must roll an ${ke.engineering} check. On a success, they clear all burn currently marked; otherwise, they take ${fe.burn} ${fe.damage} equal to the amount of burn currently marked.\n      \nBurn from additional sources adds to the total marked burn, so a character that is hit by two seperate 2 ${fe.burn} attacks first takes 4 ${fe.burn} ${fe.damage} (2 from each attack), then marks down 4 burn (again, 2 from each attack). At the end of their turn, that character makes an ${ke.engineering} check, failing, and taking an additional 4 ${fe.burn} ${fe.damage}. \n      \nNext turn, the same character gets hit by a 2 ${fe.burn} attack. They take 2 ${fe.burn} ${fe.damage}, then mark the extra burn down (now it's 6!). At the end of their turn, they must succeed on another ${ke.engineering} ${me(pe.skill_check,"check")} or take 6 ${fe.burn} ${fe.damage}.`},explosive:{name:"explosive",page:`${ue.Core}:[67]`,category:"harm",text:`Explosive is one of the ${fe.damage} types, representing the concussive force of a blast. Explosive damage is affected by ${fe.armor}.`},energy:{name:"energy",page:`${ue.Core}:[67]`,category:"harm",text:`Energy is one of the ${fe.damage} types, representing the searing heat of a laser or plasma weapon. Energy damage is affected by ${fe.armor}.`},kinetic:{name:"kinetic",page:`${ue.Core}:[67]`,category:"harm",text:`Kinetic is one of the ${fe.damage} types, representing the force of a solid projectile. Kinetic damage is affected by ${fe.armor}.`},heat:{name:"heat",page:`${ue.Core}:[67]`,category:"harm",text:`Heat is a special type of harm that doesn't count as damage and ignores ${fe.armor}, although it can be affected by ${fe.resistance}. It represents damage to a mech's internal systems and reactor. It's more often inflicted by ${pe.electronic_warfare}, but it is often generated by a mech's own ${be.systems}.\n      \nA mech that takes heat marks it on their sheet. When it reaches its ${be.heat_cap}, any additional heat causes it to ${me(fe.overheating,"overheat")}.\n      \nIf a character without a ${be.heat_cap} (such as biological characters and ${me(ye.drone,"drones")}) would take heat, they instead take an equivelant of ${fe.energy} ${fe.damage}.`},bonus_damage:{name:"bonus damage",page:`${ue.Core}:[67]`,category:"harm",text:`Some ${ke.talents}, ${be.systems} and ${me(be.weapon,"weapons")} deal bonus damage. Bonus damage can only apply to ${me(Ae.melee_attack,"melee")} and ${me(Ae.ranged_attack,"ranged")} attacks, and is only every ${fe.kinetic}, ${fe.explosive}}, or ${fe.energy} ${fe.damage} (not ${fe.burn} or ${fe.heat}).\n      \nIf no type is specified, bonus damage defaults to ${fe.kinetic} ${fe.damage}, or the attacker can choose a type from one of the same ${me(rt.type,"types")} as the ${be.weapon} that dealt it.\n      \nIf an attack that targets more than one character deals bonus damage, the bonus damage is halved.`},immunity:{name:"immunity",page:`${ue.Core}:[68]`,category:"harm",text:`Some characters and objects have immunity, and can't be affected by certain ${fe.damage} types, ${me(pe.attack,"attacks")}, or effects. Immunity goes beyond simply ignoring damage - effects or ${pe.actions} that a character has immunity to are completely ignored, and may as well have failed or not having taken place at all.\n      \nFor example, a character with immunity to ${fe.burn} doesn't take any ${fe.burn} from attacks and never counts as having taken ${fe.burn} for the purpose of any other effects. \n      \nLikewise, a character with immunity to ${fe.damage} never takes damage (even 0 damage), and a character with immunity to ${Ae.tech_attack} can't be affected by any tech attacks.`},damaging_objects:{name:"damaging objects",page:`${ue.Core}:[68]`,category:"harm",text:`Unless specified otherwise, all objects (including ${Te.terrain}, ${pe.cover}, buildings and ${me(ye.deployable,"deployable items")}) have 5 ${be.evasion} and 10 ${be.hp}/${be.size}. This means that a ${be.size} 4 object has 40 ${be.hp}.\n      \nIf an object is more usefully thought of as a group of multiple sections, each ${be.size} 1 section is independently destroyable and has 10 ${be.hp}. If an objective is especially tough or hardy, like solid rock, it might have 1-2 ${fe.armor}; if it's fortified, like a bulkhead, bunker or starship hull, it might even have 3-4 ${fe.armor}.\n      \n      \nThe GM may waive this rule outside of mech combat or when it applies to objects not created by characters (such as the environment). For instance, if a group of players want to bust through a wall in their mechs to surprise their enemies, the GM might decide that they just need to make a ${ke.hull} check.`},overheating:{name:"overheating",page:`${ue.Core}:[81]`,category:"harm",text:`When a mech exceeds its ${be.heat_cap}, it generally takes 1 ${be.stress} damage, makes an overheating check, then clears all heat. To make an overheating check, roll 1d6 per point of stress damage taken. Choose the lowest result, and check the ${fe.overheating_table} to determine the outcome. Rolling multiple 1s in a row has an especially catastrophic result.`},reactor_meltdown:{name:"reactor meltdown",page:`${ue.Core}:[81]`,category:"harm",text:`There are a few ways to trigger a reactor meltdown: ${fe.overheating} sometimes results in a reactor meltdown. This can take place immediately, or after a countdown, in which case the countdown is updated at the start of your ${pe.turn}, and the meltdown triggers when specified. \n      \nOr, a pilot can use ${we.self_destruct} to trigger a reactor meltdown manually, either at the ${me(pe.end_of_next_turn,"end of their next turn")} or at the end of one of their ${me(pe.turn,"turns")} within the following two ${me(pe.round,"rounds")} (their choice). \n      \nWhen a reactor meltdown takes place, any pilot still inside is immediately killed and the mech is vaporized in a catastrophic eruption with a ${me(rt.patterns,"burst 2")} area. The wreck is annihilated and all characters within the affected area must succeed on an agility ${me(pe.saves,"save")} or take 4d6 ${fe.explosive} ${fe.damage}. On a success, they take half damage.`},cooling:{name:"cooling",page:`${ue.Core}:[81]`,category:"harm",text:`A mech's marked ${fe.heat} can be clared with ${Ke}, or by using certain ${be.systems}. ${fe.heat} also resets when you rest or perform a ${be.full_repair}.`},overheating_table:{name:"overheating table",page:`${ue.Core}:[81]`,category:"harm",text:`5-6\nEmergency Shunt\nYour mech's cooling systems manage to contain the increasing ${fe.heat}; however, your mech becomes ${We} until the end of your next turn.\n      \n2-4\nDestabilized Power Plant\nThe power plant becomes unstable, beginning to eject jets of plasma. Your mech becomes ${je}, taking double ${fe.kinetic}, ${fe.explosive}, and ${fe.energy} damage until the status is cleared.\n      \n1\nMeltdown\nThe results depends on your mech's remaining stress: 3+ stress, your mech becomes ${je}. 2 stress: Roll an ${ke.engineering} ${me(pe.skill_check,"check")}. On a success, your mech is ${je}. On a failure, it suffers a ${fe.reactor_meltdown} after 1d6 of your turns (rolled by the GM). A reactor Meltdown can be prevented by retrying the ${ke.engineering} ${me(pe.skill_check,"check")} as a free action. 1 stress: Your mech suffers a ${fe.reactor_meltdown} at the ${me(pe.end_of_turn,"end of your turn")}.\n      \nMultiple 1s\nIrreversible Meltdown\nThe reactor goes critical - your mech suffers a ${fe.reactor_meltdown} at the ${me(pe.end_of_next_turn,"end of your next turn")}.`},destroyed:{name:"destroyed",page:`${ue.Core}:[82]`,category:"harm",text:`Destroyed mechs become wreckage - objects on the battlefield that can be moved and dragged around, and which provide ${pe.hard_cover}. Any spaces occupied by wreckage are difficult ${Te.terrain}.\n      \nIf the wreckage of a destroyed mech can be obtained (i.e., it didn't mealt in a ${fe.reactor_meltdown}), the mech can be restored to working order while resting with 4 ${me(be.repair,"repairs")}. Anyone can contribute ${me(be.repair,"repairs")} to do this, meaning that a wrecked mech can be restored even if it has insufficient ${me(be.repair,"repairs")} remaining. This is the only time pilots can share ${me(be.repair,"repairs")} like this.\n      \nOnce repaired, the mech returns to 1 ${be.structure}, 1 ${be.stress} and full ${be.hp}. Any destroyed ${me(be.weapon,"weapons")} or ${be.systems} remain unusable unless the damaged mech spends ${me(be.repair,"repairs")} to fix them as normal.`},printing:{name:"printing",page:`${ue.Core}:[82]`,category:"harm",text:`If a pilot has access to the proper facilities, they can also use a ${be.full_repair} to rebuild a mech - or build an entirely new one. Pilots are only licensed to print one mech at a time. If they print a new one, any others immediately cease to function.`}}},mt={keywords:{e_defense:{name:"E-DEFENSE",page:`${ue.Core}:[34]`,category:"mech",text:`E-Defense is a mech’s ability to resist ${pe.electronic_warfare} as well as ${ye.smart} weapons. Outside of the amount given by a ${be.frame}, a mech also gains +1 E-Defense for each point of ${ke.systems}.`},tech_attack:{name:"TECH ATTACK",page:`${ue.Core}:[64]`,category:"mech",text:`You add your mech’s ${be.tech_attack} as a bonus instead of ${ke.grit} when you conduct ${pe.electronic_warfare}, such as doing a ${Ae.tech_attack}. Outside of the amount given by a ${be.frame}, a mech also gains +1 Tech Attack for each point of ${ke.systems}.`},sensors:{name:"SENSORS",page:`${ue.Core}:[34]`,category:"mech",text:`Your mech's sensors is the maximum distance in spaces over which a mech can detect enemies, use tech ${be.systems} and make ${me(Ae.tech_attack,"tech attacks")}. If a character is within your sensors and isn't ${Pe}, you know they're there - even if they're not in ${pe.line_of_sight}.`},frame:{name:"frame",page:`${ue.Core}:[32]`,category:"mech",text:`The basic structure and components of a mech - its chassis, ${fe.armor}, and ${be.mounts} - is called its frame. A mech's frame determines its appearance, ${be.size}, and function, defining it as anything from a heavy siege engine to an agile flier, or even a cloacking mech that specializes in electronic warfare.\n      \nThese effects can be expressed by a frame's traits. Think about choosing a frame as (more or less) choosing the mech your character is going to pilot. But remember that you're not limited to just one frame - you can acquire new ones by unlocking ${me(ke.license_level,"rank II licenses")}.\n      \nIn game terms, a frame is a mech's modular base. It determines your mech's ${be.size}, ${fe.armor} & other ${be.mech_stats}, it's available ${be.weapon} ${be.mounts}, and capacity for additional ${be.systems}.\n      \nEach frame also comes with a unique core system, a powerful special ability that can typically only be used once per mission.`},mech_stats:{name:"mech stats",page:`${ue.Core}:[34]`,category:"mech",text:`Different ${me(be.frame,"frames")} have different starting statistics, giving them unique roles in combat. These stats are:\n      \n${be.hp}\n      \n${be.structure}\n      \n${be.repair_cap}\n      \n${be.speed}\n      \n${be.evasion}\n      \n${be.sensors}\n      \n${be.tech_attack}\n      \n${be.e_defense}\n      \n${be.heat_cap}\n      \n${be.stress}\n      \n${be.save_target}\n      \n\nOutside of the starting stats a ${be.frame} provides, your ${ke.mech_skills} also improve your mech's stats in the following ways:\n      \nYour pilot's ${ke.grit} is added to your mech's ${be.hp} and ${be.save_target}, as well as its ${be.system_points} and ${pe.attack} rolls.\n      \nYour mech gains +2 ${be.hp} for each point of ${ke.hull}, and +1 ${be.repair_cap} for every two points of ${ke.hull}.\n      \nYour mech gains +1 ${be.evasion} for each point of ${ke.agility}, and +1 ${be.speed} for every two points of ${ke.agility}.\n      \nYour mech gains +1 ${be.e_defense} and +1 ${be.tech_attack} for each point of ${ke.systems}, and +1 ${be.system_points} for every two points in ${ke.systems}.\n      \nYour mech gains +1 ${be.heat_cap} for each point of ${ke.engineering}, and +1 use for any limited ${me(be.weapon,"weapons")} or ${be.systems} for every two points of ${ke.engineering}.`},speed:{name:"SPEED",page:`${ue.Core}:[34]`,category:"mech",text:`Your mech's speed determines how far you can ${me(pe.movement,"move")} on your turn, in spaces when you make a standard ${me(pe.movement,"move")} or ${Ve}. Outside of the amount given by a ${be.frame}, a mech also gains +1 speed for every two points of ${ke.agility}.`},structure:{name:"STRUCTURE",page:`${ue.Core}:[80]`,category:"mech",text:`Most mechs have 4 structure and are ${fe.destroyed} when they reach 0 structure. Mechs lose 1 structure every time they go to 0 ${be.hp}, reset their HP back to full and make a structure damage check.\n      \nTo make a structure damage check, roll a 1d6 for every point of structure damage taken so far, including the damage that has just been taken. Pick the lowest number and check the ${be.structure_damage_table} to determine the outcome. Multiple 1s in a row have particularly catastrophic consequences.\n      \nNext, they take any excess damage beyond what was required to reach 0 HP. This does make it possible for a mech to take several points of structure damage and make multiple structure damage checks in one turn.`},structure_damage_table:{name:"STRUCTURE DAMAGE TABLE",page:`${ue.Core}:[80]`,category:"mech",text:`5-4\nGlancing Blow\nEmergency systems kick in and stabilize your mech, but it's ${We} until the ${me(pe.end_of_next_turn,"end of your next turn")}\n      \n2-4\nSystem Trauma\nParts of your mech are torn off by the damage. Roll 1d6. On a 1-3: All ${me(be.weapon,"weapons")} on one ${me(be.mounts,"mount")} of  your choise are destroyed; on a 4-6, a ${me(be.systems,"system")} of your choise is destroyed. limited ${me(be.weapon,"weapons")} or ${be.systems} that are out of charges are not valid choices. If there are no valid choices remaining, this result becomes a direct hit instead.\n      \n1\nDirect Hit\nThe result depends on your mech's remaining ${be.structure}: 3+ ${be.structure}: Your mech is ${Ge} until the ${me(pe.end_of_next_turn,"end of your next turn")}; 2 ${be.structure}: Roll a ${ke.hull} check. On a success, your mech is ${Ge} until the ${me(pe.end_of_next_turn,"end of your next turn")}. On a failure, your mech is ${fe.destroyed}; 1 ${be.structure}: Your mech is ${fe.destroyed}.\n      \nMultiple 1s\nCrushing Hit\nYour mech is damaged beyond repair - it is ${fe.destroyed}. You may still exit as normal.`},evasion:{name:"EVASION",page:`${ue.Core}:[34]`,category:"mech",text:`Evasion is how hard it is for ${me(Ae.melee_attack,"melee")} and ${me(Ae.ranged_attack,"ranged")} attacks to hit you. Outside of the amount given by a ${be.frame}, a mech also gains +1 evasion for each point of ${ke.agility}.`},hp:{name:"HP",page:`${ue.Core}:[34]`,category:"mech",text:`Like your ${me(ke.pilot_mech_stats,"pilot")}, your mech has HP. When your mech takes damage, it loses HP. If it reaches 0 HP, it is not ${fe.destroyed} but rather takes 1 ${be.structure} damage. Outside of the amount given by a ${be.frame}, a mech also gains +2 HP for each point of ${ke.hull} and +1 for each point of ${ke.grit}.`},repair_cap:{name:"REPAIR CAP",page:`${ue.Core}:[34]`,category:"mech",text:`${me(be.repair,"repairs")} are a kind of currency that you can use to heal and repair your mech. If your mech runs out of ${me(be.repair,"repairs")}, you can no longer regain ${be.hp} or fix damaged ${be.systems} in the field. Outside of the amount given by a ${be.frame}, a mech also gains +1 repair cap for every two points of ${ke.hull}.`},heat_cap:{name:"HEAT CAP",page:`${ue.Core}:[34]`,category:"mech",text:`Your mech can take some ${fe.heat} from ${me(Ae.tech_attack,"tech attacks")} and some of its own ${be.systems}. If it takes more damage than its heat cap, it ${me(fe.overheating,"overheats")}. When a mech reaches above its heat cap, it takes 1 ${be.stress} damage. Outside of the amount given by a ${be.frame}, a mech also gains +1 heat cap for each point of ${ke.engineering}.`},stress:{name:"STRESS",page:`${ue.Core}:[34]`,category:"mech",text:`Most mechs have 4 stress and are ${fe.destroyed} when they reach 0 stress. Whenever a mech loses stress, it has to do an ${fe.overheating} check.`},save_target:{name:"SAVE TARGET",page:`${ue.Core}:[34]`,category:"mech",text:`When you force another character to make a save, they must match or beat your mech's save target or take consequences. Outside of the amount given by a ${be.frame}, a mech also gains +1 save target for each point of ${ke.grit}.`},weapon:{name:"WEAPON",page:`${ue.Core}:[33]`,category:"mech",text:`Mech weapons have three traits: ${rt.size}, ${rt.type}, and ${rt.damage}. They can also have ${ye.tags} that give them additional special properties.`},systems:{name:"SYSTEMS",page:`${ue.Core}:[33]`,category:"mech",text:`Every ${be.frame} comes with a core system. These powerful abilities are ${ye.unique} to each ${be.frame}, can't be transferred to other mechs, and in most cases can only be used once a mission by assumping ${be.core_power}. Outside of these powerful frame-unique systems, every mech also has a set number of ${be.system_points} that can be spent to add extra systems to your mech. Some heavier weapons require both ${be.mounts} and ${be.system_points}. You cannot add systems to your mech that would cause you to exceed your available ${be.system_points}.`},system_points:{name:"SYSTEM POINTS",page:`${ue.Core}:[33]`,category:"mech",text:`Every mech also has a set number of ${be.system_points} that can be spent to add extra ${be.systems} to your mech. Some heavier weapons require both ${be.mounts} and ${be.system_points}. You cannot add ${be.systems} to your mech that would cause you to exceed your available ${be.system_points}.\n      \n      Your pilot's ${ke.grit}, equal to half their ${ke.license_level}, is added to your total ${be.system_points}, and you gain an additional +1 ${be.system_points} for each point of ${ke.systems}.`},core_power:{name:"CORE POWER",page:`${ue.Core}:[33]`,category:"mech",text:`Mechs only have 1 core power, which is used to activate their ${be.frame}'s core system. You have it or you don't, it can't be saved up but it does replenish when they perform a ${be.full_repair}. Though sometimes a GM might grant additional core power as a powerful reward or boon.`},size:{name:"SIZE",page:`${ue.Core}:[32]`,category:"mech",text:`All mechs, characters and ${me(Te.obstruction,"objects")} on the battlefield have a size that describes how large they are, in grid spaces, on each side (rounded up to 1 if smaller, so a size 1/2 and size 1 character occupy the same space). Size is an abstract measurement - it doesn't describe a precise height and width in meters, but the space a character controls around them. Humans and the smallest mechs are size 1/2. Most mechs are size 1, but some are as large as size 3.`},repair:{name:"REPAIR",page:`${ue.Core}:[82]`,category:"mech",text:`As long as pilots have repairs available from their ${be.repair_cap}, they can spend repairs in a variety of ways, in combat they do this via ${Ke} - regaining all ${be.hp} - at the cop of 1 repair - as well as certain ${be.systems}.\n      \nPilots can also repair their mechs whilst ${me(be.rest,"resting")}. `},full_repair:{name:"FULL REPAIR",page:`${ue.Core}:[82]`,category:"mech",text:`When a character spends at least 10 hours relatively uninterrupted in a secure location, they can perform a full repair. A full repair allows them to:\n      \nRestore all pilot HP and clear ${Ee};\n      \nRestore a mech to full ${be.hp}, ${be.stress}, and ${be.structure}, as long as it's intact or the wreckage is accessible;\n      \nClear all ${me(pe.status,"statuses")} and ${me(pe.condition,"conditions")};\n      \nRepair any destroyed ${be.weapon} or ${be.systems}.\n      \nRecover ${be.core_power}, if used;\n      \nRegain all ${be.repair_cap} and uses of ${me(ye.limited_x,"limited")} weapons.\n      \n${fe.printing} a new mech and equipment, with the proper facilities.`},rest:{name:"REST",page:`${ue.Core}:[82]`,category:"mech",text:`To rest, pilots require at least an hour of interrupted downtime or light activity (e.g., making camp or performing routine maintenance). After resting, characters may:\n      \nClear all ${fe.heat};\nClear any ${me(pe.status,"statuses")} and ${me(pe.condition,"conditions")} affecting their mech;\nRestore half of their pilot's HP and clear ${Ee}.\n      \nThey may also spend ${me(be.repair,"repairs")} at the following costs:\n      \n1 ${be.repair}: Restore full ${be.hp}, or repair a destroyed weapon or system;\n2 ${me(be.repair,"repairs")}: restore 1 ${be.structure} or 1 ${be.stress};\n4 ${me(be.repair,"repairs")}: Repair a ${fe.destroyed} mech.`},mounts:{name:"MOUNTS",page:`${ue.Core}:[32]`,category:"mech",text:`Mechs can only carry a limited number of ${me(be.weapon,"weapons")}, determined by their ${be.frame}. Each mech ${be.frame} has a different number and types of mounts. To add a ${be.weapon} to your mech, you need an available mount of the right type and size. You can, however, add smaller weapons to larger mounts.\n      \nThe following mounts are available:\n      ${be.main_mount}\n${be.heavy_mount}\n${be.aux_aux_mount}\n${be.main_aux_mount}\n${be.flexible_mount}\n${be.integrated_mount}\n${be.superheavy_mount}\n      \nWeapons mounted on a mech aren't neccesarily attached to the chassis, they can be slung in holsters, built into compartments, or held normally. You decide how your mech's weapons are mounted - it has no effect on the rules.`},main_mount:{name:"MAIN MOUNT",page:`${ue.Core}:[32]`,category:"mech",text:`A main ${me(be.mounts,"mount")} can take one ${rt.main} or ${rt.auxiliary} ${be.weapon}.`},heavy_mount:{name:"HEAVY MOUNT",page:`${ue.Core}:[32]`,category:"mech",text:`Heavy ${be.mounts} can take one ${rt.heavy}, ${rt.main}, or ${rt.auxiliary} ${be.weapon}.`},aux_aux_mount:{name:"AUX/AUX MOUNT",page:`${ue.Core}:[32]`,category:"mech",text:`Aux/aux ${be.mounts} can take up to two ${rt.auxiliary} ${me(be.weapon,"weapons")}.`},main_aux_mount:{name:"MAIN/AUX MOUNT",page:`${ue.Core}:[32]`,category:"mech",text:`Main/aux ${be.mounts} can take one ${rt.main} ${be.weapon} and one ${rt.auxiliary} ${be.weapon}, or two ${rt.auxiliary} ${me(be.weapon,"weapons")}.`},flexible_mount:{name:"FLEXIBLE MOUNT",page:`${ue.Core}:[32]`,category:"mech",text:`Flexible ${be.mounts} can take either one ${rt.main} ${be.weapon}, or up to two ${rt.auxiliary} ${me(be.weapon,"weapons")}`},integrated_mount:{name:"INTEGRATED MOUNT",page:`${ue.Core}:[32]`,category:"mech",text:`Integrated ${be.mounts} are built around specific ${me(be.weapon,"weapons")}, built into ${me(be.frame,"frames")}. They automatically include the listed ${me(be.weapon,"weapons")}, which cannot be destroyed, removed, replaced, or modified in any way.`},superheavy_mount:{name:"SUPERHEAVY WEAPONS",page:`${ue.Core}:[32]`,category:"mech",text:`Superheavy ${me(be.weapon,"weapons")}, which are especially large, require both a ${rt.heavy} ${me(be.mounts,"mount")} and one other ${me(be.mounts,"mount")} of any size, rather than having their own ${me(be.mounts,"mount")}.`}}},ut={keywords:{obstruction:{name:"obstruction",page:`${ue.Core}:[62]`,category:"movement",text:`An obstruction is anything that blocks passage, preventing ${pe.movement} into its space entirely. Obstructions are typically environmental but other characters can also be obstructions. Characters are obstructed by any solid objects or characters that are the same ${be.size} as them or larger.\n      \nCharacters can freely pass through spaces occupied by obstructions smaller than them, including other characters; however, they can't end a ${pe.movement} in a space that is occupied by another character or object unless specified. This means that a ${be.size} 2 mech, for example, could move through the space of a ${be.size} 1 mech or object, but could not finish its move in the same space.\n      \nAllied characters never cause obstruction, but characters still can't end moves in their space. Additionally, mechs can always move through spaces occupied by unmounted humans.`},adjacency:{name:"adjacency",page:`${ue.Core}:[62]`,category:"movement",text:`Characters are considered adjacent to another character or object when they are within one space of it in any direction - even diagonal and vertical. This can trigger ${Te.engagement} in the case of two characters hostile to each other.`},splitting_movement:{name:"splitting movement",page:`${ue.Core}:[62]`,category:"movement",text:`Any time characters voluntarily move, whether it's a standard ${me(pe.movement,"move")} or something else (like ${Ve}), they can split up their ${pe.movement} with any ${pe.actions}; however, when they do this, any non-movement ${pe.actions} they take must fully resolve before they continue moving.\n      \nFor example, a mech with 6 ${be.speed} could move 4 spaces, ${Be}, and then move two more spaces; however, it would need to complete the full ${Be} action - firing with two ${be.mounts} - before moving those final 2 spaces. It couldn't fire one ${me(be.mounts,"mount")}, move two spaces, and then fire another ${me(be.mounts,"mount")}.`},engagement:{name:"engagement",page:`${ue.Core}:[62]`,category:"movement",text:`If a character moves ${me(Te.adjacency,"adjacent")} to a hostile character, they both gain the ${Ie} status as long as they remain ${me(Te.adjacency,"adjacent")} to one another. Ranged attacks made by an ${Ie} character receive +1 ${xe}.\n      \nAdditionally, characters that become ${Ie} by characters of equal or greater ${be.size} during the course of a ${pe.movement} action stop moving immediately and lose any unused ${pe.movement}. \n      \nAfter you have become engaged ${Ie} with a character, you may make further move actions as normal and moving into other adjacent spaces does not stop your movement, though beginning a ${me(pe.movement,"move")} within that character's ${pe.threat} may provoke ${pe.reactions} such as ${nt}.`},terrain:{name:"terrain",page:`${ue.Core}:[62]`,category:"movement",text:`Mech combat takes place on many types of worlds in countless hostile and hazardous environments. There are two terrain types with mechanics:\n      \nDifficult terrain can be anything from rough, marshy or swampy ground, through to icy landscapes, and treacherous rocky scree. All ${pe.movement} through difficult terrain is at half ${be.speed} - each space of difficult terrain they move into is equivelant to two spaces of ${pe.movement}.\n      \nDangerous terrain is even more hazardous, and comprises of things such as intense radiation, boiling gases, lava, and falling rocks. When characters ${me(pe.end_of_turn,"end their turn")} in dangerous terrain, or move into it for the first time in a round, they must make an ${ke.engineering} ${me(pe.skill_check,"check")}. On a failure, they take 5 ${fe.damage} - ${fe.kinetic}, ${fe.energy}, ${fe.explosive}, or ${fe.burn}, depending on the hazard.\n      Each character only needs to make one such ${me(pe.skill_check,"check")} per round, so once they've made it, they're safe to move around in the hazardous terrain until the ${me(pe.end_of_next_turn,"end of their next turn")}.`},lifting:{name:"lifting",page:`${ue.Core}:[62]`,category:"movement",text:`Mechs can lift characters or objects of equal or lesser ${be.size} overhead, but are ${He} while doing so. While lifting, characters can't take ${pe.reactions}. The same rules apply to pilots and other characters on foot, but they can't lift anything above ${be.size} 1/2. See also: ${Te.dragging}.`},dragging:{name:"dragging",page:`${ue.Core}:[62]`,category:"movement",text:`Mechs can drag characters or objects up to twice their ${be.size}, but are ${Ye} while doing so. While dragging, characters can't take ${pe.reactions}. The same rules apply to pilots and other characters on foot, but they can't drag anything above ${be.size} 1/2. See also: ${Te.lifting}.`},jumping:{name:"jumping",page:`${ue.Core}:[63]`,category:"movement",text:`Characters with legs can jump instead of using their standard ${me(pe.movement,"move")}. They may jump horizontally, moving half their ${be.speed} in a straight line and ignoring obstructions at ground level that they could jump over (such as pits or gaps).\nOr they may jump vertically, moving 1 space adjacent and moving up by spaces equivelant to their ${be.size}. For example, a ${be.size} 1 mech could jump up to 1 space high, and 1 space over. Characters that jump and end the jump mid air automatically ${me(Te.falling,"fall")} at the end of the move. See also: ${Te.climbing}.`},climbing:{name:"climbing",page:`${ue.Core}:[63]`,category:"movement",text:`Like moving through difficult ${Te.terrain}, characters climb at half their usual ${be.speed} - each space moved is equivelant to moving 2 spaces normally. A succesful ${ke.hull} or ${ke.agility} ${me(pe.skill_check,"check")} might be required to climb particularly difficult surfaces without ${Te.falling}. See also: ${Te.jumping}.`},falling:{name:"falling",page:`${ue.Core}:[63]`,category:"movement",text:`Characters take ${fe.damage} when they fall three or more spaces and cannot recover before hitting the ground. In standard circumstances, characters fall 10 spaces per round, but mechs can't fall in zero-g or low-g environments, and falling speeds may differ depending on the location.\n      \nUnless specified otherwise, characters start to fall at the end of the current turn, and fall at the end of each of their turns thereafter. They take 3 ${fe.kinetic} ${ye.armor_piercing} ${fe.damage} for every three spaces fallen, to a maximum of 9 ${fe.kinetic} ${ye.armor_piercing} ${fe.damage}.\n      \n      Falling is a type of involuntary movement, and can trigger effects triggered by involuntary movement.`},gravity:{name:"gravity",page:`${ue.Core}:[63]`,category:"movement",text:`Mechs operating underwater, in zero-g, or even in space are ${Ye} unless they have a propulsion or flight system; however, they can't fall and can fly when moving regardless of whether they have a flight system.`},flight:{name:"flight",page:`${ue.Core}:[63]`,category:"movement",text:`Some characters can fly for either all or part of their ${pe.movement}. Flying characters can move vertically and horizontally up to their ${be.speed}. For example, a mech with a flight system and 6 ${be.speed} could end its movement anywhere within six spaces of its starting location, up to a maximum of 6 spaces high.\n      \nFlight ${pe.movement} must follow a straight line; however, if a character takes additional ${pe.movement} ${pe.actions}, such as ${Ve}, these can be used to move in a different direction.\n      \nWhen flying, characters ignore ${Te.obstruction} as long as it is physically possible for them to do so - they couldn't, for instance, move through a gap smaller than their mech's ${be.size}. Flying characters also have ${fe.immunity} to ${qe}.\n      \nFlying also comes with some risks:\n      When flying, characters must move at least 1 space on their ${pe.turn} or begin ${Te.falling}.\n      Flying characters begin ${Te.falling} if they become ${He}, ${Ge} or otherwise can't move.\n      Flying characters that take ${be.structure} ${fe.damage} or ${be.stress} must succeed on an agility ${me(pe.saves,"save")} or begin falling.\n      \nDuring mech combat, characters that fly too high above the battlefield can only take certain ${pe.actions}. Flying characters must remain no more than 10 spaces over any surface (e.g., ground, water, structures) to act normally. For example, a flying mech could move 10 spaces above the ground or float 10 spaces above a building five spaces high - a total of 15 spaces above the ground - and still act.\n      \nCharacters cannot move beyond this distance if they have already taken an action in the same turn; if they do move more than 10 spaces above the battlefield, they can only ${me(pe.movement,"move")} and ${Ve}, and cannot take reactions until they start their turn below that celing.\n      \nThis restriction does not exist in zero-g and outside of mech combat.\n      \nExcept in zero-g environments, characters cannot carry characters or object with a total ${be.size} larget than ${be.size} 1/2 while flying - there's just not enough thrust!\n      \nSome very advanced mechs can hover. Hovering characters do not need to move in a straight line, and can remain stationary while airborne without ${Te.falling}.`},teleportation:{name:"teleportation",page:`${ue.Core}:[63]`,category:"movement",text:`Some characters can teleport, instantly moving to any free space within a specified ${pe.range}. They must start and end a teleport on a surface they can normally move on; for example, a character that can't ${me(Te.flight,"fly")} can't teleport mid-air.\n      \nTeleportation ignores ${me(Te.obstruction,"obstructions")}, does not require ${pe.line_of_sight}, ignores ${Te.engagement}, and does not provoke ${pe.reactions}; however, it still counts as movement and so is affected by conditions like ${He}. A teleporting character counts as moving 1 space, no matter how far they actually travelled.\n      \nCharacters can attempt to teleport to spaces they can't see, but if a space is already occupied, the teleport fails.`}}},$t={archaic:`$${$e["Pilot Gear"]}#archaic$`,personal_armor:`$${$e["Pilot Gear"]}#personal_armor$`,gear:`$${$e["Pilot Gear"]}#gear$`,sidearm:`$${$e["Pilot Gear"]}#sidearm$`},gt={ai:ve,attacks:ze,bonuses:Re,combat:st,condition:ct,fullAction:ht,gear:lt,harm:dt,mech:mt,movement:ut,otherAction:{keywords:{activate:{name:"activate",page:`${ue.Core}:[71]`,category:"otherAction",text:`When you activate, you use a ${me(be.systems,"system")} or piece of ${$t.gear} that requires either a ${me(pe.quick_action,"quick")} or ${me(pe.full_action,"full")} action. These systems have the ${pe.quick_action} or ${pe.full_action} ${ye.tags}. You can activate any number of times a ${pe.turn}, but can't active the same ${me(be.systems,"system")} more than once unless you can do so as a ${pe.free_action}.`},boot_up:{name:"boot up",page:`${ue.Core}:[71]`,category:"otherAction",text:`You can boot up a mech that you are piloting as a ${pe.full_action}, clearing ${Oe} and restoring your mech to a powered state.`},mount:{name:"mount",page:`${ue.Core}:[71]`,category:"otherAction",text:`When you mount, you climb onto your mech. Mounting is a ${pe.full_action}, you must be adjacent to your mech to mount. Additionally, you can also mount willing allied mechs or vehicles. When you do so, move into the same space and then move with them. See this as sitting in the passenger seat, or sitting on a mech's shoulders.\n      \nMounting and ${me(we.dismount,"dismounting")} are the preferred terms amongst most pilots. You don't "get in" or "climb aboard" - you mount. You're the cavalry, after all.`},dismount:{name:"dismount",page:`${ue.Core}:[71]`,category:"otherAction",text:`When you dismount, you climb off your mech. Dismounting is a ${pe.full_action}. When you dismount, you are placed in an adjacent space - if there are no free spaces, you cannot dismount. Additionally, dismounting is also how you get off allied mechs or vehicles you might be riding along with. Lastly, if you need to get off your mech quickly, you can always ${we.eject}. \n      \n${me(we.mount,"mounting")} and dismounting are the preferred terms amongst most pilots. You don't "get in" or "climb aboard" - you mount. You're the cavalry, after all.`},eject:{name:"eject",page:`${ue.Core}:[71]`,category:"otherAction",text:`Ejecting is a ${pe.quick_action}, flying 6 spaces in the direction of your choice; however, this is a single-use system for emergency use only - it leaves your mech ${We}. Your mech remains ${We} and you cannot eject again until your next ${be.full_repair}.`},prepare:{name:"prepare",page:`${ue.Core}:[71]`,category:"otherAction",text:`When you prepare, you turn another ${pe.quick_action} into a ${me(pe.reactions,"reaction")}. As a ${pe.quick_action}, you can prepare any other ${pe.quick_action} and specify a trigger. Until the start of your next turn, when it is triggered, you can take this ${me(pe.actions,"action")} as a ${me(pe.reactions,"reaction")}.\n      \nThe trigger for your prepared ${me(pe.actions,"action")} must be phrased as "When X, then Y" where X is a ${me(pe.reactions,"reaction")}, ${me(pe.actions,"action")}, or ${me(pe.movement,"move")} taken by a hostile or allied character and Y is your ${pe.quick_action}. For example, "When an allied character moves ${me(Te.adjacency,"adjacent")} to me, I want to ${me(ye.thrown_x,"throw")} a smoke ${ye.grenade}." or "When a hostile character moves ${me(Te.adjacency,"adjacent")} to me, I want to ${et} them."\n      \nYour preparation counts as taking the action, so it follows all usual restrictions on that action and on taking multiple actions. You can't, for example, ${at} and then use prepare to ${at} again; you also can't ${me(pe.movement,"move")} and then prepare to ${at} with an ordnance weapon, which normally needs to be fired before moving or doing anything else on your turn.\n      \nAdditionally, after you prepare an action, you can't ${me(pe.movement,"move")} or take any other ${me(pe.actions,"action")} or ${pe.reactions} until the start of your next turn or until your action has been triggered, whichever comes first.\n      \nAlthough you can't take ${pe.reactions} while holding a prepared action, you can take them normally after it has been triggered. You can also drop your prepared action, allowing you to take ${pe.reactions} as usual. If the trigger condition isn't met, you lose your prepared action.\n      \nWhen you prepare, it is visible to casual observers (e.g., you clearly take aim or cycle up systems).`},self_destruct:{name:"self-destruct",page:`${ue.Core}:[72]`,category:"otherAction",text:`When you self-destruct, you overload your mech's react in a final, catastrophic play if there's no other option for escape or you deem your sacrifice necessary.\n      \nYou can self-destruct as a ${pe.quick_action}, initiating a ${fe.reactor_meltdown}. At the ${me(pe.end_of_next_turn,"end of their your turn")} or at the end of one of your ${me(pe.turn,"turns")} within the following two ${me(pe.round,"rounds")} (your choice), your mech explodes as though it suffered a ${fe.reactor_meltdown}.`},shut_down:{name:"shut down",page:`${ue.Core}:[72]`,category:"otherAction",text:`When you shut down, your mech powers completely off and enters a rest state. It's always risky to do in the field, but sometimes necessary to prevent a catastrophic systems ${me(fe.overheating,"overload")} or an ${ge.nhp} ${me(ge.cascade,"cascading")}.\n      \nYou can shut down as a ${pe.quick_action}. Your mech takes the ${Oe}, with these effects:\n      All ${fe.heat} is cleared, as is ${je};\n      Any ${me(ge.cascade,"cascading")} ${me(ge.nhp,"NHPs")} return to a normal state.;\n      Any statuses or conditions affecting the mech caused by ${it.tech_actions}, such as ${Ue}, immediately end;\n      The mech gains ${fe.immunity} to all ${it.tech_actions} and ${me(Ae.tech_attack,"attacks")}, including any from allied characters;\n      The mech is ${Ge} indefinitely. Nothing can prevent this ${pe.condition}, and it remains until the mech ceases to be ${Oe}.\n      \nThe only way to remove the ${Oe} ${pe.status} is to ${we.boot_up} the mech.`},skill_check:{name:"skill check",page:`${ue.Core}:[72]`,category:"otherAction",text:`When you make a skill check, you undertake an activity that isn't covered by other ${pe.actions} but has a clear goal and is sufficient complex to require a roll. The parameters and outcomes of skill checks are up to the GM, but they must be involved enough to require a ${pe.full_action}. If you want to do something that can be done quickly, no action is required.\n      \nBruja, on foot, wants to open a locked door. The GM asks her to make a skill check and decide that Bruja can get a bonus from her 'Hack or Fix' ${me(ke.triggers,"trigger")}.\n      Pan wants to jump a crevasse in his mech that's wider than he can normally manage with ${Te.jumping}. The GM decides to allow him to try it with ${ke.agility}.\n      Zaid wants to lift a heavy boulder with his mech, to clear a passage. The GM decides this is probably a full action and requires a skill check with ${ke.hull}.\n      \nSkill check as a term is also used for checks made as part of equipment or otherwise during play, these do not require a full action and are covered in ${pe.skill_check}.`}}},pilot:{keywords:{mech_skills:{name:"MECH SKILLS",page:`${ue.Core}:[30]`,category:"pilot",text:`Your lancer has four mech skills that represent their ability to build, pilot and fight with mechs:\n      \n${ke.hull}: describes your ability to build and pilot durable, structurally sound mechs that can take punches and keep going.\n      ${ke.agility}: describes your ability to build and pilot fast, evasive mechs.\n      ${ke.systems}: describes your ability to build and pilot advanced mechs with powerful ${pe.electronic_warfare} capabilities.\n      ${ke.engineering}: describes your ability to build and pilot mechs with effective reactors, supplies and support systems.\n      \nMech skills go from +0 to +6 and are used when you make ${pe.skill_check} that utilize your mech. \n      In mech combat, for example when making ${pe.saves}.\n      For additional bonuses when building mechs, see ${be.mech_stats}.`},pilot_mech_stats:{name:"PILOT COMBAT STATS",page:`${ue.Core}:[28]`,category:"pilot",text:`When in combat, pilots have a set of stats similar to mech stats that are used when playing a pilot in mech combat. They might need to bail out of their mech during a fight, or you might want to track your pilot's ${be.hp} if they get injured during downtime.\n      \nPilots have the following statistics:\n      ${be.hp}: 6 + ${ke.grit}\n      ${be.size}: 1/2\n      ${be.evasion}: 10\n      ${be.e_defense}: 10\n      ${be.speed}: 4\n      \nTheir statistics (especially their ${be.hp}) might also change if they're wearing ${$t.personal_armor}.`},hull:{name:"HULL",page:`${ue.Core}:[30]`,category:"pilot",text:`Your mech gains +2 ${be.hp} for each point of ${ke.hull}, and +1 ${be.repair_cap} for every two points of ${ke.hull}.`},agility:{name:"AGILITY",page:`${ue.Core}:[30]`,category:"pilot",text:`Your mech gains +1 ${be.evasion} for each point of ${ke.agility}, and +1 ${be.speed} for every two points of ${ke.agility}.`},systems:{name:"SYSTEMS",page:`${ue.Core}:[30]`,category:"pilot",text:`Your mech gains +1 ${be.e_defense} and +1 ${be.tech_attack} for each point of ${ke.systems}, and +1 ${be.system_points} for every two points in ${ke.systems}.`},engineering:{name:"ENGINEERING",page:`${ue.Core}:[30]`,category:"pilot",text:`Your mech gains +1 ${be.heat_cap} for each point of ${ke.engineering}, and +1 use for any limited ${me(be.weapon,"weapons")} or ${be.systems} for every two points of ${ke.engineering}.`},grit:{name:"GRIT",page:`${ue.Core}:[14]`,category:"pilot",text:`Pilots are lucky and unique individuals, multi-talented and resilient. Even so, brand-new pilots don’t measure up to tempered, battle-hardened veterans when push comes to shove. The benefits of experience are measured by GRIT, a bonus that reflects your pilot’s deep reservoirs of resolve and will to live. \nGRIT is half of your character’s ${ke.license_level}, rounded up. It improves ${pe.attack} bonuses, ${be.hp}, and ${me(pe.saves,"save")} targets for both your pilot and your mech.`},talents:{name:"TALENTS",page:`${ue.Core}:[35]`,category:"pilot",text:`Talents are your pilot's personal ingenuity and experience piloting a mech. They give your pilot further abilities and benefits when playing with specific ${be.weapon} ${me(rt.type,"types")}, ${be.systems}, or styles of play.\n      \nTalents, like ${me(ke.license_level,"licenses")} are measured in in ranks: from rank I to rank III. At ${me(ke.license_level,"LL0")} you start with three rank I talents of your choice. When your pilot levels up, you can either increase a talent to the next rank, or choose a new talent at rank I. When you level up, you are also allowed to reshuffle all ranks from one talent.`},triggers:{name:"TRIGGERS",page:`${ue.Core}:[25]`,category:"pilot",text:`During narrative play, your pilot will have moments in the story when their background, training or personality shine through. These moments are your pilot's triggers: short phrases that describe key decisions and actions like "Apply Fists to Faces" or "Get Somewhere Fast". Triggers are always accompanied by a bonus of +2, +4 or +6.\n      \nWhen one of your character's triggers is relevant to a ${pe.skill_check}, you get a bonus to that roll. For example, if you have "+2 to Apply Fists to Faces" written on your sheet, any time your character acts in a way that could be construed as applying fists to faces, you get +2 to the ${pe.skill_check}. You can only receive a bonus from one trigger at a time.\n      \nTriggers only apply to your pilot's actions, not your mech's. When taking actions that rely on a mech, ${ke.mech_skills} are used instead.\n      \nTriggers are fairly open-ended, allowing you to apply them in creative ways. That said, the GM is responsible for arbitrating outlandish claims. Be prepared to justify how your "Apply Fists to Faces" trigger helps you hack into an electronic network.\n      \nYou can also create your own custom triggers, with GM approval. Custom triggers can be more specific than the ones in the core book, but they shouldn't be more general. They should always apply to specific circumstances or actions.`},pilot_actions:{name:"PILOT ACTIONS",page:`${ue.Core}:[74]`,category:"pilot",text:`When a pilot is outside of a mech during mech combat, they follow the same pool of ${pe.actions} as mechs: one standard ${me(pe.movement,"move")}, and two ${me(pe.quick_action,"quick actions")} or one ${pe.full_action}. \n      \nYou can split your actions between pilot and mech, too, if you so choose. For example: Take a ${pe.quick_action} to ${at} with your mech, take a ${pe.quick_action} to ${we.eject}. and then use your ${me(pe.movement,"move")} to run to cover on foot.\n      \nPilots have access to the following normal actions: ${Ve}, ${Je}, ${tt}, ${we.activate}, ${we.activate}, ${Fe}, ${we.prepare}, & ${we.mount}. Pilots can also use the ${nt} ${me(pe.reactions,"reaction")}, and use the ${ke.fight} action when they do so.\n      \nThey also have access to three special pilot actions: ${ke.fight}, ${ke.jockey}, & ${ke.reload}.`},fight:{name:"FIGHT",page:`${ue.Core}:[74]`,category:"pilot",text:`When you fight, you ${pe.attack} (${me(Ae.melee_attack,"melee")} or ${me(Ae.ranged_attack,"ranged")}) with one ${be.weapon} as a ${pe.full_action}.\n      \nTo fight, choose a ${be.weapon} and attack a target within ${pe.range} or ${pe.threat} and ${pe.line_of_sight} as a ${pe.full_action}. ${me(Ae.ranged_attack,"ranged attacks")} are affected by ${pe.cover} and receive +1 ${xe} if you're ${Ie}.`},jockey:{name:"JOCKEY",page:`${ue.Core}:[75]`,category:"pilot",text:`When you Jockey, you aggressively attack an enemy mech while on foot. This is extremely dangerous. To Jockey, you must be ${me(Te.adjacency,"adjacent")} to a mech. As a ${pe.full_action}, make a ${pe.contested_skill_check} against the mech, using ${ke.grit} (or a relevant ${me(ke.triggers,"trigger")} at the GM's discretion). The mech contests with ${ke.hull}. On a success, you manage to climb onto the mech, sharing its space and moving with it. The mech can attempt to shake you off by succeeding on another ${pe.contested_skill_check} as a ${pe.full_action}; alternatively, you can jump off as part of your ${pe.movement} on your turn.\n      \nWhen you succeed Jockey, choose one of the following options:\n      Distract: the mech is ${We} and ${Ye} until the end of its next turn.\n      Shred: Deal 2 ${fe.heat} to the mech by ripping at wiring, paneling, and so on.\n      Damage: Deal 4 ${fe.kinetic} ${fe.damage} to the mech by attacking joints, hatches, and so on.\n      \nOn each of your subsequent turns, you can continue to choose from the options above as ${me(pe.full_action,"full actions")}, as long as you don't stop jockeying (or get thrown off).`},reload:{name:"RELOAD",page:`${ue.Core}:[75]`,category:"pilot",text:`When you reload with a ${pe.quick_action}, you reload one ${me($t.gear,"pilot weapon")} with the ${ye.loading} ${me(ye.tags,"tag")}, making it usable again.`},license_level:{name:"LICENSE LEVEL",page:`${ue.Core}:[18]`,category:"pilot",text:`License levels are the equivelant of character levels in Lancer. The total amount of licenses you have obtained are your license level (LL). A new pilot typically starts at LL0, and levels up to LL1 after their first mission, then again after each subsequent missino to a maximum of LL12. You spend these license levels to gain licenses with various manufacturers for mech gear, ${me(be.weapon,"weapons")}, ${be.systems}, and ${me(be.frame,"frames")}.\n      \nOutside of the licenses, levelling up also lets your pilot improve their ${ke.triggers}, ${ke.mech_skills}, and ${ke.grit}, and lets you choose ${ke.talents} to further customize your play.\n      \nEvery time your LL increases, you also have the option to choose one:\n      Reallocate all ranks from one of your ${ke.talents} to any other ${me(ke.talents,"talent")}.\n      Reallocate all ranks from one of your licenses to any other license.\n      Replace one ${me(ke.core_bonuses,"core bonus")} with another ${me(ke.core_bonuses,"core bonus")} for which your pilot qualifies.\n      \nIf reallocating ranks from one license to another means your pilot no longer qualifies for a ${me(ke.core_bonuses,"core bonus")}, you must replace that ${me(ke.core_bonuses,"core bonus")} with one you now qualify for.`},core_bonuses:{name:"CORE BONUSES",page:`${ue.Core}:[35]`,category:"pilot",text:`As your pilot acquires more ${me(ke.license_level,"licenses")}, they gain knowledge and skills specific to individual manufacturers and their design philosophies. Core bonuses are permanent improvements you that apply to any ${be.frame} your pilot uses. You cannot choose the same core bonus more than once, but as your pilot progresses you will be able to choose a range of different bonuses.\n      \nYour pilot gets a new core bonus every three ${me(ke.license_level,"LLs")}. You can always choose core bonuses from the GMS list, but for each core bonus you choose from another manufacturer, you first need to have three license ranks with that manufacturer. For example, to choose a core bonus from IPS-Northstar (IPS-N), you would need at least three ranks in IPS-N licenses; if you wanted to choose a second IPS-N bonus, you would need at least six ranks in licenses.\n      \nThese ranks can be in any combination - for example, you might have the rank I and rank II licenses for one mech, and then three different rank I licenses, equaling six in total.`}}},pilotGear:{keywords:{archaic:{name:"archaic",page:`${ue.Core}:[106]`,category:"pilot gear",text:"This weapon is old-fashioned and can't harm mechs."},personal_armor:{name:"personal armor",page:`${ue.Core}:[106]`,category:"pilot gear",text:"This gear offers protection in combat, but it is obvious to observers and can't be hidden. Only one piece of personal armor can be worn at a time. Putting on personal armor takes 10-20 minutes, and while wearing it, pilots have restricted mobility and dexterity. Nobody wears armor unless they're expecting to go into a warzone."},gear:{name:"gear",page:`${ue.Core}:[106]`,category:"pilot gear",text:"This is a tool, piece of equipment, or another item. Pilots can have up to three of these at a time."},sidearm:{name:"sidearm",page:`${ue.Core}:[106]`,category:"pilot gear",text:`This weapon can be used to ${ke.fight} as a ${pe.quick_action} instead of a ${pe.full_action}.`}}},quickAction:{keywords:{boost:{name:"barrage",page:`${ue.Core}:[69]`,category:"quick action",text:`When you boost, you move at least 1 space, up to your speed. This allows you to make an extra ${pe.movement}, on top of your standard ${me(pe.movement,"move")}. Certain ${ke.talents} and ${be.systems} can only be used when you boost, not when you make a standard ${me(pe.movement,"move")}.`},grapple:{name:"grapple",page:`${ue.Core}:[69]`,category:"quick action",text:`When you grapple, you try to grab hold of a target and overpower them - disarming, subduing, or damaging them so they can't do the same to you.\n      \nTo grapple, choose an ${me(Te.adjacency,"adjacent")} character and make a ${Ae.melee_attack}. On a hit:\n      \nBoth characters become ${Ie};\n      Neither character can ${Ve} or take ${pe.reactions} for the duration of the grapple;\n      The smaller character becomes ${He} but moves when the larger party moves, mirroring their ${pe.movement}. If both parties are the same ${be.size}, either can make ${me(pe.contested_skill_check,"contested")} ${ke.hull} checks at the start of their turn: the winner counts as larger than the loser until the contest is repeated.\n      \nA grapple ends when:\n      \nEither character breaks ${Te.adjacency}, such as if they are ${me(ye.knockback,"knocked back")} by another effect;\n      The attacker chooses to end the grapple as a ${pe.free_action};\n      The defender breaks free by succeeding on a ${me(pe.contested_skill_check,"contested")} ${ke.hull} check as a ${pe.quick_action}.\n      \nIf a grapple involves more than two characters, the same rules apply, but when counting ${be.size}, add together the ${be.size} of all characters on each side. For example, if two ${be.size} 1 allied characters are grapping a single ${be.size} 2 enemy, the allied characters count as a combined ${be.size} 2 and the same size for the purpose of grapple.`},hide:{name:"hide",page:`${ue.Core}:[69]`,category:"quick action",text:`When you hide, you obscure the position of your mech in order to reposition, avoid incoming fire, ${be.repair}, or ambush.\n      \nTo hide, you must not be ${Ie} and you must either be outside of any enemies' ${pe.line_of_sight}, obscured by sufficient ${pe.cover}, or ${me(pe.invisibility,"invisible")}. If you hide while meeting one of those criteria, you gain the ${Pe} ${pe.status}.\n      \n${pe.hard_cover} is sufficient to hide as long as it is large enough to totally conceal you, but ${pe.soft_cover} is only sufficient if you are completely inside an area or zone that grants ${pe.soft_cover} - many ${be.systems} and ${ke.talents} that grain ${pe.soft_cover} or plain old obscurement just don't provide enough to hide behind!\n      \nIf you are ${me(pe.invisibility,"invisible")}, you can always hide, regardless of ${pe.cover}, unless you're ${Ie}.\n      \nThe exact location of hidden targets cannot be identified and they cannot be targeted directly by attacks or hostile actions, but they can still be hit by attacks that affect an area. Although NPCs cannot perfectly locate a hidden character, they might still know an approximate location. Thus, an NPC could flush an area with a flamethrower, even if they don't know exactly where a hidden player is lurking.\n      \nAdditionally, other characters ignore ${Te.engagement} with you while you are ${Pe} - it's assumed you're trying to stay stealthy.\n      \nYou cease to be ${Pe} if you make an ${pe.attack}, (${me(Ae.melee_attack,"melee")}, ${me(Ae.ranged_attack,"ranged")}, or ${me(Ae.tech_attack,"tech")}) or if your mech takes a hostile action (such as forcing a target to make a ${me(pe.saves,"save")}). Using ${Ve} or taking ${pe.reactions} with your mech also causes you to lose ${Pe}. Other actions can be taken as normal.\n      \nYou also immediately lose ${Pe} if your ${pe.cover} disappears or is destroyed, or if you lose ${pe.cover} due to ${pe.line_of_sight} (e.g., if a mech ${me(Te.jumping,"jumps")} over a wall and can now draw an unbroken line of ${pe.line_of_sight} to you). If you're ${Pe} while ${Me}, you lose ${Pe} when you cease to be ${Me} unless you are in ${pe.cover}.`},quick_tech:{name:"quick tech",page:`${ue.Core}:[69]`,category:"quick action",text:`When you use quick tech, you engage in ${pe.electronic_warfare}, countermeasures, and other technical actions, often aided by a mech's powerful computing and simulation cores.\n      \nEach time you take this action, you choose an option from the ${me(it.tech_actions,"quick tech list")}. All mechs have access to these options, but some systems enhance them or make new options available.\n      \nUnlike other actions, quick tech can be taken more than once per turn; however, a different option must be chosen every time, unless specified otherwise or granted as a ${pe.free_action}.`},ram:{name:"ram",page:`${ue.Core}:[70]`,category:"quick action",text:`When you ram, you make a ${Ae.melee_attack} with the aim of knocking a target down or back.\n      \nTo ram, make a ${Ae.melee_attack} against an ${me(Te.adjacency,"adjacent")} character the same ${be.size} or smaller than you. On a success, your target is knocked ${qe} and you may also choose to knock them back by one space, directly away from you.`},search:{name:"search",page:`${ue.Core}:[70]`,category:"quick action",text:`When you search, you attempt to identify ${Pe} characters. To search in a mech, choose a character within your ${be.sensors} that you suspect is ${Pe} and make a ${me(pe.contested_skill_check,"contested")} ${ke.systems} check against their ${ke.agility}.\n      \nTo search as a pilot on foot, make a ${pe.contested_skill_check}, adding bonuses from triggers as normal. This can be used to reveal characters within ${pe.range} 5.\n      \nOnce a ${Pe} character has been found using search, they immmediately lose ${Pe} and can be located again by any character.`},skirmish:{name:"skirmish",page:`${ue.Core}:[70]`,category:"quick action",text:`When you skirmish, you attack with a single ${be.weapon}.\n      \nTo skirmish, choose a ${be.weapon} and a valid target within ${pe.range} (or ${pe.threat}) then make an ${pe.attack}.\n      \nIn addition to your primary attack, you may also attack with a different ${rt.auxiliary} ${be.weapon} on the same ${me(be.mounts,"mount")}. That weapon doesn't deal bonus damage.\n      \n${rt.superheavy} ${me(be.weapon,"weapons")} are too cumbersome to use in a skirmish, and can only be fired as part of a ${Be}.`}}},reaction:{keywords:{brace:{name:"brace",page:`${ue.Core}:[73]`,category:"reaction",text:`1/round\n      \nTrigger: You are hit by an attack and damage has been rolled.\n      \nEffect: You count as having ${fe.resistance} to all ${fe.damage}, ${fe.burn} and ${fe.heat} from the triggering attack, and until the ${me(pe.end_of_next_turn,"end of your next turn")}, all other attacks against you are made with +1 ${xe}.\n      Due to the stress of bracing, you cannot take ${pe.reactions} until the ${me(pe.end_of_next_turn,"end of your next turn")} and on that ${pe.turn}, you can only take one ${pe.quick_action} - you cannot ${pe.overcharge}, ${me(pe.movement,"move")} normally, take ${me(pe.full_action,"full actions")}, or take ${me(pe.free_action,"free actions")}.`},overwatch:{name:"overwatch",page:`${ue.Core}:[73]`,category:"reaction",text:`1/round\n      \nTrigger: A hostile character starts any ${pe.movement} (including ${Ve} and other ${pe.actions}) inside one of your ${me(be.weapon,"weapons")} ${pe.threat}. Unless specified otherwise, all weapons default to 1 ${pe.threat}.\n      \nEffect: Trigger overwatch, immediately using that ${be.weapon} to ${at} against that character as a ${me(pe.reactions,"reaction")}, before they move.`}}},status:{keywords:{danger_zone:{name:"brace",page:`${ue.Core}:[77]`,category:"status",text:`Characters are in danger_zone when half or more of their ${be.heat_cap} is filled in. They're smoking hot, which enables some ${me(pe.attack,"attacks")}, ${ke.talents}, and effects.`},down_and_out:{name:"down and out",page:`${ue.Core}:[77]`,category:"status",text:`Pilots that are down and out are unconscious and ${Ge} - if they take any more ${fe.damage}, they die. They'll regain consciousness and half of their ${be.hp} when they ${be.rest}.`},engaged:{name:"engaged",page:`${ue.Core}:[77]`,category:"status",text:`If a character moves ${me(Te.adjacency,"adjacent")} to a hostile character, they both gain the engaged ${pe.status} for as long as they remain ${me(Te.adjacency,"adjacent")} to one another. ${me(Ae.ranged_attack,"ranged attacks")} made by engaged characters receive +1 ${xe}. Additionally, characters that become engaged by targets of equal or greater ${be.size} during the course of a ${pe.movement} must stop moving immediately and lose any unused movement.`},exposed:{name:"exposed",page:`${ue.Core}:[77]`,category:"status",text:`Characters become exposed when they're dealing with runaway ${fe.heat} buildup - their armor is weakened by ${fe.overheating}, their vents are open, and their weapons are spinning down, proving plenty of weak points. All ${fe.kinetic}, ${fe.explosive}, or ${fe.energy} ${fe.damage} taken by exposed characters is doubled, before applying any reductions. A mech can clear exposed by taking the ${Ke} action.`},hidden:{name:"hidden",page:`${ue.Core}:[77]`,category:"status",text:`Hidden characters can't be targeted by hostile ${me(pe.attack,"attacks")} or ${pe.actions}, don't cause ${Te.engagement}, and enemies only know their approximate location. ${me(pe.attack,"attacking")}, forcing ${pe.saves}, taking ${pe.reactions}, using ${Ve}, and losing ${pe.cover} all remove hidden after they resolve. Characters can find hidden characters with ${tt} and hide with ${Je}.`},invisible:{name:"invisible",page:`${ue.Core}:[77]`,category:"status",text:`All attacks against invisible characters, regardless of ${rt.type}, have a 50 percent chance to miss outright, before an ${pe.attack} roll is made. Roll a dice or flip a coin to determine if the attack misses.\n      \nAdditionally, invisible characters can always ${Je}, even without ${pe.cover}.`},prone:{name:"prone",page:`${ue.Core}:[77]`,category:"status",text:`Attacks against prone targets receive +1 ${_e}.\n      \nAdditionally, prone characters are ${Ye} and count as moving in difficult ${Te.terrain}. Characters can remove prone by standing up instead of taking their standard ${me(pe.movement,"move")}, unless they're ${He}. Standing up doesn't count as ${pe.movement}, so doesn't trigger ${nt} or other effects.`},shut_down:{name:"shut down",page:`${ue.Core}:[77]`,category:"status",text:`When a mech is shut down:\n      \nAll ${fe.heat} is cleared, as is ${je};\n      Any ${me(ge.cascade,"cascading")} ${me(ge.nhp,"NHPs")} return to a normal state.;\n      Any statuses or conditions affecting the mech caused by ${it.tech_actions}, such as ${Ue}, immediately end;\n      The mech gains ${fe.immunity} to all ${it.tech_actions} and ${me(Ae.tech_attack,"attacks")}, including any from allied characters;\n      The mech is ${Ge} indefinitely. Nothing can prevent this ${pe.condition}, and it remains until the mech ceases to be ${Oe}.\n      \nThe only way to remove the ${Oe} ${pe.status} is to ${we.boot_up} the mech.`}}},techAction:{keywords:{bolster:{name:"bolster",page:`${ue.Core}:[69]`,category:"tech action",text:`When you Bolster, you use your mech's formidable processing power to enhance another character's ${be.systems}.\n      \nTo Bolster, choose a character within ${be.sensors}. They receive +2 ${_e} on the next ${pe.skill_check} or ${me(pe.saves,"save")} they make between now and the ${me(pe.end_of_next_turn,"end of their next turn")}.\n      Characters can only benefit from one bolster at a time.`},scan:{name:"scan",page:`${ue.Core}:[70]`,category:"tech action",text:`When you Scan, you use  your mech's powerful sensors to perform a deep scan on an enemy.\n      \nTo Scan, choose a character within ${be.sensors} and ${pe.line_of_sight}, then ask the GM for one of the following pieces of information, which they must answer honestly:\n      Your target's weapons, systems, and full statistics (${be.mech_stats}).\n      One piece of hidden information about the target, such as confidential cargo or data, current mission, the identity of the pilot, and so on.\n      Generic or public information about the target that can be pulled from an info bank or records, such as the model number of the mech.\n      \nAny information gathered is only current at the time of the scan - if the target later takes damage, for instance, you don't receive an update.`},lock_on:{name:"lock on",page:`${ue.Core}:[70]`,category:"tech action",text:`When you Lock On, you digitally mark a target, lighting them up for your teammates' targeting systems and exposing weak points.\n      \nTo Lock On, choose a character within ${be.sensors} and ${pe.line_of_sight}. They gain the ${Ue} ${pe.condition}. Any character making an ${pe.attack} against a character with ${Ue} may choose to gain +1 ${_e} on that attack and then clear the ${Ue} ${pe.condition} after that attack resolves. This is called consuming ${Ue}.`},invade:{name:"invade",page:`${ue.Core}:[70]`,category:"tech action",text:`When you Invade, you mount a direct electronic attack against a target. To Invade, make a ${Ae.tech_attack} against a characters within ${be.sensors} and ${pe.line_of_sight}. On a success, your target takes ${fe.heat} and you choose one of the invasion options available to you.\n      \nThe only invasion option available by default to all characters is ${it.fragment_signal}, other options are gained through ${be.systems} and equipment.\n      \nYou can also Invade willing allied characters to create certain effects. If your target is willing and allies, you are automatically succesful, it doesn't count as an ${pe.attack}, and your target doesn't take any ${fe.heat}.`},fragment_signal:{name:"fragment signal",page:`${ue.Core}:[70]`,category:"tech action",text:`You feel false information, obscene messages or phantom signals to your target's computing core. They become ${We} and ${Ye} until the end of their next turn.`},tech_actions:{name:"tech actions",page:`${ue.Core}:[69]`,category:"tech action",text:`The following tech actions are available to all characters by default:\n      ${it.bolster}\n      ${it.scan}\n      ${it.lock_on}\n      ${it.invade}\n      \nYou can also take tech actions granted by pilot ${ke.talents}, mech's ${be.systems}, or equipment.`}}},weapon:{keywords:{size:{name:"size",page:`${ue.Core}:[33]`,category:"weapon",text:`${me(be.weapon,"weapons")} come in different sizes, which determine how they can be used and which ${be.mounts} they fit in. ${me(be.weapon,"weapons")} can have the following sizes:\n      \n${rt.auxiliary}\n      ${rt.main}\n      ${rt.heavy}\n      ${rt.superheavy}`},type:{name:"type",page:`${ue.Core}:[33]`,category:"weapon",text:`There are six types of weapon which describe their general ${pe.range} and combat function. These types are:\n      \n${rt.melee}\n      ${rt.cqb}\n      ${rt.rifle}\n      ${rt.launcher}\n      ${rt.cannon}\n      ${rt.nexus}`},damage:{name:"damage",page:`${ue.Core}:[33]`,category:"weapon",text:`Most ${me(be.weapon,"weapons")} deal one of three kinds of ${fe.damage}: ${fe.kinetic}, ${fe.explosive}, or ${fe.energy}. Some special ${me(be.weapon,"weapons")} also deal ${fe.burn} (damage over time) or ${fe.heat} (harm to a mech's internal systems).`},auxiliary:{name:"auxiliary",page:`${ue.Core}:[33]`,category:"weapon",text:`Auxiliary ${me(be.weapon,"weapons")} are the smallest ${rt.size} mech ${me(be.weapon,"weapons")}, light enough to use alongside larger ${me(be.weapon,"weapons")}.`},superheavy:{name:"superheavy",page:`${ue.Core}:[33]`,category:"weapon",text:`Superheavy ${me(be.weapon,"weapons")} are very large ${rt.size} ${me(be.weapon,"weapons")} with high power requirements; they often take up multiple ${be.mounts} They are usually rare or highly advanced.`},main:{name:"main",page:`${ue.Core}:[33]`,category:"weapon",text:`Main ${me(be.weapon,"weapons")} are the standard ${rt.size} for mech ${me(be.weapon,"weapons")}.`},heavy:{name:"heavy",page:`${ue.Core}:[33]`,category:"weapon",text:`Heavy ${me(be.weapon,"weapons")} are heavier, larger ${rt.size} ${me(be.weapon,"weapons")}, used to inflict massive damage.`},melee:{name:"melee",page:`${ue.Core}:[33]`,category:"weapon",text:`Melee ${me(be.weapon,"weapons")} are mech-scale swords, axes, power tools and other hand-to-hand ${me(be.weapon,"weapons")}. A mech's raw strength can turn even crude tools into forces to be reckoned with.`},cqb:{name:"QCB",page:`${ue.Core}:[33]`,category:"weapon",text:`QCB (Close Quarters Battle) ${me(be.weapon,"weapons")} are those designed for close-range combat, including pistols, shotguns, flamethrowers, and more exotic ${me(be.weapon,"weapons")} like nailguns. They usually have short range, but are better for reacting quickly to emergent threats.`},rifle:{name:"rifle",page:`${ue.Core}:[33]`,category:"weapon",text:`Rifles are sturdy ${me(be.weapon,"weapons")} with good range and stopping power.`},launcher:{name:"launcher",page:`${ue.Core}:[33]`,category:"weapon",text:`Launchers are ${me(be.weapon,"weapons")} that fire missiles, grenades or other projectiles.`},cannon:{name:"cannon",page:`${ue.Core}:[33]`,category:"weapon",text:`Cannons are high-caliber ${me(be.weapon,"weapons")} useful for inflicting heavy damage on enemies. What they lack in precision, they usually make up for in power.`},nexus:{name:"nexus",page:`${ue.Core}:[33]`,category:"weapon",text:`Nexus ${me(be.weapon,"weapons")} are resevoirs and projectors for swarms of self-propelled, armed drones.`},patterns:{name:"patterns",page:`${ue.Core}:[64]`,category:"weapon",text:`Some ${me(be.weapon,"weapons")} and ${be.systems} have special ${pe.attack} patterns. These ${pe.attack} affect all targets within a defined area. A seperate ${pe.attack} roll is made for each target, but ${fe.damage} is only rolled once and bonus ${fe.damage} is halved if there are multiple characters affected. For any ability or effect calling for you to choose a target or targets within ${pe.range}, a ${be.weapon} can choose any target that would be hit by its pattern.\n      \nLine X: Affects characters in a straight line, X spaces long.\n      \nCone X: Affects characters within a cone, X spaces long and X spaces wide at its furthers point. The cone begins at one space wide.\n      \nBlast X: Affects characters within a radius of X spaces, drawn from a point within ${pe.range} and ${pe.line_of_sight}. ${pe.cover} and ${pe.line_of_sight} are calculated based on the center of the blast, rather than the position of the attacker.\n      \nBurst X: Affects characters within a radius of X spaces, centered on and including the space occupied by the user (or target). If the Burst is an ${pe.attack}, the user or target is not affected by the ${pe.attack} unless specified. ${pe.cover} and ${pe.line_of_sight} are calculated from the character. If a Burst effect is ongoing, it moves with the character at its center.\n      \nSome Line, Cone, Burst and Blast attacks list a ${pe.range}. In these cases, the attack's point of origin can be drawn from a point within the ${pe.range} specified and ${pe.line_of_sight}.\n      \nSome mech ${me(be.frame,"frames")} also grant increased ${pe.range}. This does not affect the size of the pattern, although it does increase the ${pe.range} of such attacks that have a listed ${pe.range}.`}}}};class pt extends re{constructor(){super(...arguments),this.keyword={name:"",text:"",page:"",category:""},this.x=0,this.y=0}createRenderRoot(){return this}connectedCallback(){super.connectedCallback(),document.body.contains(this)||document.body.appendChild(this)}firstUpdated(){this.constrainPosition()}constrainPosition(){const e=this.querySelector(".lancer-card"),t=e?.clientWidth||0,a=e?.clientHeight||0,o=window.innerWidth,n=window.innerHeight;this.x+t/2>o?this.x=o-t:this.x-t/2<0?this.x=0:this.x-=t/2,this.y+a>n&&(this.y=n-a),this.y<0&&(this.y=0)}propagateClick(e){e.stopPropagation();const t=this.parentElement;if(t){t.querySelectorAll(".lancer-card-clickthrough").forEach((t=>{if(t!==this&&!t.classList.contains("clicked")){const a=t.nextElementSibling.getBoundingClientRect(),o=e.clientX,n=e.clientY,r=a.left,s=r+a.width,i=a.top,c=i+a.height;(o<r||o>s||n<i||n>c)&&(t.classList.add("clicked"),t.dispatchEvent(new MouseEvent("click",{bubbles:!0,composed:!0,clientX:o,clientY:n})),t.classList.remove("clicked"))}}))}this.remove()}render(){const e=this.keyword.text.split("$").map((e=>{if(""===e)return L``;if(e.includes("#")){const[t,a,o]=e.split("#"),n=gt[t];if(!n)return L`${e}`;const r=n.keywords[a];return r?L`<span
          ><lancer-keyword .keyword=${r}
            >${o}</lancer-keyword
          ></span
        >`:L`${e}`}return L`${e}`}));return L`
      <div>
        <style>
          ${de}
        </style>
        <div
          class="lancer-card-clickthrough"
          @click=${this.propagateClick}
          @keydown=${this.propagateClick}
        ></div>
        <div
          class="lancer-card lancer-card-${this.keyword.category.toLowerCase().replace(" ","")}"
          style="top: ${this.y}px; left: ${this.x}px;"
        >
          <div class="lancer-card-header">
            <p class="lancer-card-header-name">${this.keyword.name}</p>
            <p class="lancer-card-header-category">${this.keyword.category}</p>
          </div>
          <div class="lancer-card-body">
            <p class="lancer-card-body-text">${e}</p>
            <div class="lancer-card-page">
              <div class="lancer-card-page-triangle"></div>
              <div class="lancer-card-page-line"></div>
              <p class="lancer-card-page-number">${this.keyword.page}</p>
            </div>
            <div class="lancer-card-body-clear"></div>
          </div>
        </div>
      </div>
    `}}e([he({type:Object})],pt.prototype,"keyword",void 0),e([he({type:Number})],pt.prototype,"x",void 0),e([he({type:Number})],pt.prototype,"y",void 0),window.customElements.define("lancer-card",pt);class yt extends re{constructor(){super(...arguments),this.keyword={name:"",text:"",page:"",category:""},this.alt="",this.cards=[]}connectedCallback(){if(super.connectedCallback(),this.alt.length>0&&this.alt.includes("/")){const[e,t]=this.alt.split("/"),a=gt[e];if(a){const e=a.keywords[t];e&&(this.keyword=e)}}}clickHandler(e){this.cards.push(L`<lancer-card
        .keyword=${this.keyword}
        x=${e.x}
        y=${e.y}
      ></lancer-card>`),this.requestUpdate()}render(){return L`<span
        class="lancer-keyword lancer-keyword-${this.keyword.category.toLowerCase().replace(" ","")}"
        @click=${this.clickHandler}
        @keydown=${e=>"Enter"===e.key&&this.clickHandler(new MouseEvent("click"))}
        tabindex="0"
        ><slot>${this.keyword.name}</slot></span
      >${this.cards.map((e=>e))}`}}yt.styles=le,e([he({type:Object})],yt.prototype,"keyword",void 0),e([he({type:String})],yt.prototype,"alt",void 0),window.customElements.define("lancer-keyword",yt);
